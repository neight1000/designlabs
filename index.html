<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Visual EQ Enhanced</title>
  <style>
    html, body {
      margin: 0; padding: 0; overflow: hidden;
      background: #000; color: #fff;
      font-family: sans-serif;
      height: 100vh; width: 100vw;
    }
    #controls {
      position: absolute; top: 10px; left: 50%;
      transform: translateX(-50%);
      display: flex; flex-wrap: wrap; gap: 8px; align-items: center;
      z-index: 10; transition: opacity .5s;
      background: rgba(0,0,0,0.5); padding: 6px; border-radius: 4px;
    }
    select, button, label, input[type=range] {
      background: #000; color: #fff;
      border: 1px solid #fff; padding: 4px 8px;
      font-size: 1rem;
    }
    label { display: flex; align-items: center; gap: 4px; }
    input[type=range] { width: 80px; }
    canvas {
      position: absolute; top: 0; left: 0;
      width: 100vw; height: 100vh;
      display: block;
      cursor: pointer;
    }
    @media (max-width: 700px) {
      #controls { flex-direction: column; gap: 4px; }
      select, button, label, input[type=range] { font-size: 0.9rem; }
    }
  </style>
</head>
<body>
  <div id="controls" role="form" aria-label="EQ Controls">
    <label for="deviceSelect">Input</label>
    <select id="deviceSelect" aria-label="Audio input device"></select>
    <button id="startBtn" aria-label="Start visualization">Start</button>
    <label for="fftSelect">FFT</label>
    <select id="fftSelect" aria-label="FFT size">
      <option>256</option><option selected>512</option>
      <option>1024</option><option>2048</option>
      <option>4096</option><option>8192</option>
      <option>16384</option><option>32768</option>
    </select>
    <label for="presetSelect">Preset</label>
    <select id="presetSelect" aria-label="EQ preset">
      <option value="vhs">VHS Drift</option>
      <option value="tape">Tape Echo</option>
      <option value="neon">Neon Grid</option>
      <option value="aurora">Aurora</option>
      <option value="spectrum">Spectrum Cascade</option>
      <option value="pultec">Pultec EQ</option>
      <option value="neve">Neve EQ</option>
      <option value="ssl">SSL EQ</option>
    </select>
    <label for="sensSlider">Sensitivity
      <input type="range" id="sensSlider" min="0.5" max="3" step="0.05" value="1.15" aria-label="Sensitivity">
    </label>
    <label for="tracerToggle">
      <input type="checkbox" id="tracerToggle" checked aria-checked="true"> Tracers
    </label>
    <label for="crossfadeToggle">
      <input type="checkbox" id="crossfadeToggle" aria-checked="false"> Crossfade
    </label>
    <label for="momentsToggle">
      <input type="checkbox" id="momentsToggle" aria-checked="false"> Moments
    </label>
    <label for="beatThreshold">Beat Thr
      <input type="range" id="beatThreshold" min="0.1" max="1" step="0.05" value="0.7" aria-label="Beat threshold">
    </label>
    <label for="beatCooldown">Cooldown
      <input type="range" id="beatCooldown" min="0.1" max="2" step="0.1" value="0.3" aria-label="Beat cooldown">
    </label>
    <button id="fsBtn" aria-label="Fullscreen">Fullscreen</button>
  </div>
  <canvas id="vis" aria-label="Audio visualizer"></canvas>
  <div id="fallback" style="display:none;position:absolute;top:40%;left:50%;transform:translate(-50%,-50%);color:#f43;font-size:1.1em;background:#222;padding:1em 2em;border-radius:6px;"></div>
  <script>
    // --- Helper: Debounce for resize ---
    function debounce(fn, delay) {
      let timer; return function(...args) {
        clearTimeout(timer);
        timer = setTimeout(()=>fn.apply(this, args), delay);
      }
    }

    // --- DOM Elements ---
    const $ = id => document.getElementById(id);
    const deviceSelect    = $('deviceSelect');
    const startBtn        = $('startBtn');
    const fftSelect       = $('fftSelect');
    const presetSelect    = $('presetSelect');
    const sensSlider      = $('sensSlider');
    const tracerToggle    = $('tracerToggle');
    const crossfadeToggle = $('crossfadeToggle');
    const momentsToggle   = $('momentsToggle');
    const beatThreshold   = $('beatThreshold');
    const beatCooldown    = $('beatCooldown');
    const fsBtn           = $('fsBtn');
    const controls        = $('controls');
    const canvas          = $('vis');
    const fallback        = $('fallback');
    const ctx             = canvas.getContext('2d');

    // --- State ---
    const state = {
      audioContext: null, splitter: null,
      leftAnalyser: null, rightAnalyser: null,
      dataLeft: null, dataRight: null, dataMid: null,
      startTime: 0,
      mainPreset: presetSelect.value,
      xfadeActive: false, xfadeStart: 0, xfadeDur: 5, nextXfade: 0,
      secondaryPreset: presetSelect.value,
      lastBeatTime: 0, momentHue: 0, momentHueAlpha: 0,
      // For trailing bar effect in spectrum
      spectrumTrails: []
    };

    // --- Utility Functions ---
    const fract = x => x - Math.floor(x);
    const rand = n => fract(Math.sin(n)*43758.5453123);
    function noise1D(x){ const i=Math.floor(x), f=fract(x); return rand(i)*(1-f)+rand(i+1)*f; }

    // --- Responsive Canvas ---
    function resizeCanvas() {
      canvas.width  = window.innerWidth;
      canvas.height = window.innerHeight;
      // Reset spectrum trails on resize
      state.spectrumTrails = [];
    }
    window.addEventListener('resize', debounce(resizeCanvas, 100));
    document.addEventListener('fullscreenchange', resizeCanvas);
    resizeCanvas();

    // --- Device Enumeration ---
    async function populateDevices() {
      try {
        const devs = await navigator.mediaDevices.enumerateDevices();
        deviceSelect.innerHTML = '';
        devs.filter(d=>d.kind==='audioinput').forEach((d,i)=>{
          const o=document.createElement('option');
          o.value=d.deviceId; o.textContent=d.label||`Mic ${i+1}`;
          deviceSelect.append(o);
        });
      } catch (e) {
        showFallback('Could not enumerate audio devices.');
      }
    }

    // --- Fallback Handler ---
    function showFallback(msg) {
      fallback.style.display = 'block';
      fallback.textContent = msg;
      controls.style.display = 'none';
      canvas.style.display = 'none';
    }

    // --- Audio Setup and Start ---
    async function startEQ() {
      if(state.audioContext) return;
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        showFallback('Web Audio API not supported in this browser.');
        return;
      }
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          audio: { deviceId: deviceSelect.value || undefined }
        });
        state.audioContext = new (window.AudioContext||window.webkitAudioContext)();
        state.splitter = state.audioContext.createChannelSplitter(2);
        state.leftAnalyser = state.audioContext.createAnalyser();
        state.rightAnalyser = state.audioContext.createAnalyser();
        state.leftAnalyser.fftSize = state.rightAnalyser.fftSize = parseInt(fftSelect.value);
        state.leftAnalyser.smoothingTimeConstant = state.rightAnalyser.smoothingTimeConstant = 0.8;
        state.dataLeft = new Uint8Array(state.leftAnalyser.frequencyBinCount);
        state.dataRight = new Uint8Array(state.rightAnalyser.frequencyBinCount);
        state.dataMid = new Uint8Array(state.leftAnalyser.frequencyBinCount);
        const src = state.audioContext.createMediaStreamSource(stream);
        src.connect(state.splitter);
        state.splitter.connect(state.leftAnalyser, 0);
        state.splitter.connect(state.rightAnalyser, 1);
        state.startTime = performance.now();
        state.nextXfade = state.startTime/1000 + 300 + Math.random()*300;
        state.spectrumTrails = [];
        draw();
      } catch (e) {
        showFallback('Permission denied or no input device found.');
      }
    }

    // --- Event Listeners ---
    fftSelect.addEventListener('change', ()=>{
      if(!state.leftAnalyser) return;
      state.leftAnalyser.fftSize = state.rightAnalyser.fftSize = parseInt(fftSelect.value);
      state.dataLeft = new Uint8Array(state.leftAnalyser.frequencyBinCount);
      state.dataRight = new Uint8Array(state.rightAnalyser.frequencyBinCount);
      state.dataMid = new Uint8Array(state.leftAnalyser.frequencyBinCount);
      state.spectrumTrails = []; // reset trails on FFT size change
    });
    presetSelect.addEventListener('change', ()=> state.mainPreset = presetSelect.value);

    // --- PRESET DEFINITIONS ---
    // Each preset is modular, dynamic, and audio-reactive
    const EQ_PRESETS = {
      vhs: {
        name: 'VHS Drift',
        sensitivity: 1.15,
        mainColor: ctx => 'hsl(0,0%,80%)',
        sideColor: ctx => 'hsl(0,0%,80%)',
        curveDash: true,
        beforeDraw: (ctx, state, options) => {
          // Simulate tape drift: vertical/horizontal jitter, random glitches
          ctx.save();
          // Small vertical frame "jitter"
          let yJitter = Math.sin(options.t*2) * 2 + (Math.random()-0.5)*2*state.momentHueAlpha;
          ctx.translate(0, yJitter);

          // Occasional rolling bar glitch
          if (Math.random() < 0.004 + state.momentHueAlpha*0.05) {
            let barY = Math.random() * canvas.height;
            ctx.fillStyle = `rgba(255,255,255,0.05)`;
            ctx.fillRect(0, barY, canvas.width, 12+(Math.random()*16));
          }

          // Horizontal scanlines
          ctx.strokeStyle = 'rgba(255,255,255,0.06)';
          ctx.lineWidth = 1;
          for(let y=0; y<canvas.height; y+=4){
            const off = 2 * Math.sin(y/50 + options.t*3);
            ctx.beginPath(); ctx.moveTo(off, y);
            ctx.lineTo(canvas.width+off, y); ctx.stroke();
          }
        },
        afterDraw: ctx => ctx.restore()
      },
      tape: {
        name: 'Tape Echo',
        sensitivity: 1.2,
        mainColor: ctx => 'hsl(200,100%,80%)',
        sideColor: ctx => 'hsl(200,100%,80%)',
        beforeDraw: (ctx, state, options) => {
          // Faded echo trail using a translucent overlay
          ctx.save();
          ctx.globalAlpha = 0.12 + state.momentHueAlpha*0.1;
          ctx.fillStyle = "#1a2233";
          ctx.fillRect(0,0,canvas.width,canvas.height);
          ctx.globalAlpha = options.alpha * 0.7;
          ctx.shadowBlur = 30; ctx.shadowColor = '#fff';

          // Overlay slow sine wave for tape flutter
          ctx.strokeStyle = "rgba(255,255,255,0.08)";
          ctx.lineWidth = 2;
          ctx.beginPath();
          for (let x = 0; x < canvas.width; x += 6) {
            let y = canvas.height * 0.5 + Math.sin(options.t + x/100 + Math.sin(options.t*0.7)*2) * 18;
            if(x === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          ctx.stroke();
        },
        afterDraw: ctx => { ctx.shadowBlur = 0; ctx.restore(); }
      },
      neon: {
        name: 'Neon Grid',
        sensitivity: 1.1,
        mainColor: ctx => {
          // Animate hue with beat
          return `hsl(${180 + state.momentHue*state.momentHueAlpha},100%,60%)`;
        },
        sideColor: ctx => 'hsl(180,100%,60%)',
        beforeDraw: (ctx, state, options) => {
          // Animated grid, color pulses with beat
          ctx.save();
          const baseHue = 180 + state.momentHue * state.momentHueAlpha;
          ctx.strokeStyle = `hsl(${baseHue},100%,60%)`;
          ctx.lineWidth = 1 + 2 * state.momentHueAlpha;
          const gridSpacing = 50 + 6 * Math.sin(options.t); // animated grid spacing
          for(let x=0; x<canvas.width; x+=gridSpacing){
            ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke();
          }
          for(let y=0; y<canvas.height; y+=gridSpacing){
            ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke();
          }
          ctx.shadowBlur = 20; ctx.shadowColor = `hsl(${baseHue},100%,80%)`;
        },
        afterDraw: ctx => { ctx.shadowBlur = 0; ctx.restore(); }
      },
      aurora: {
        name: 'Aurora',
        sensitivity: 1.0,
        mainColor: ctx => {
          // Animated gradient background
          const grad = ctx.createLinearGradient(0,0,0,canvas.height);
          grad.addColorStop(0,'#081d71');
          grad.addColorStop(0.5 + 0.1*Math.sin(state.momentHue*0.01 + performance.now()*0.0005),'#20ff90');
          grad.addColorStop(1,'#081d71');
          return grad;
        },
        sideColor: ctx => 'hsl(120,100%,50%)',
        alpha: 0.5,
        beforeDraw: (ctx, state, options) => {
          // Draw moving "ribbons" for aurora effect (bass-driven)
          ctx.save();
          for(let k=0; k<3; k++) {
            ctx.beginPath();
            for(let x=0; x<canvas.width; x+=3){
              let freq = 0.001*k + 0.0005*Math.sin(options.t + k);
              let y = canvas.height*0.7 - 70*Math.sin(options.t*0.7 + x*freq + k*2)
                      - 40*Math.sin(options.t*0.8 + x*freq*1.3 + k*4)
                      + 30*Math.sin(options.t + k*3);
              if(x===0) ctx.moveTo(x,y);
              else ctx.lineTo(x,y);
            }
            ctx.strokeStyle = `hsla(${130+40*k},90%,70%,${0.25+0.2*k+0.2*state.momentHueAlpha})`;
            ctx.lineWidth = 2 + 2*k;
            ctx.stroke();
          }
        },
        afterDraw: ctx => ctx.restore()
      },
      spectrum: {
        name: 'Spectrum Cascade',
        sensitivity: 1.2,
        customDraw: (ctx, state, options) => {
          // Trailing bars with glow, color pulses on beat
          const bins = state.dataMid.length, slice = canvas.width/bins, sens = options.sens;
          // Initialize or resize trails
          if (state.spectrumTrails.length !== bins) {
            state.spectrumTrails = Array(bins).fill(0);
          }
          for(let i=0;i<bins;i++){
            let f = Math.min(state.dataMid[i]/255 * sens,1);
            let x=i*slice, h=(i/bins*360)%360, barH=f*canvas.height;
            // Save trailing value
            state.spectrumTrails[i] = Math.max(barH, state.spectrumTrails[i]*0.92);
            // Main bar
            ctx.fillStyle=`hsl(${h + state.momentHue*state.momentHueAlpha},100%,60%)`;
            ctx.fillRect(x,canvas.height-state.spectrumTrails[i],slice,state.spectrumTrails[i]);
            // Trailing glow
            ctx.globalAlpha = 0.15 + 0.2*state.momentHueAlpha;
            ctx.fillStyle=`hsl(${h},100%,90%)`;
            ctx.fillRect(x,canvas.height-state.spectrumTrails[i]-6,slice,state.spectrumTrails[i]+6);
            ctx.globalAlpha = 1;
          }
        }
      },
      pultec: {
        name: 'Pultec EQ',
        sensitivity: 1.2,
        mainColor: ctx => `hsl(30,100%,60%)`,
        beforeDraw: (ctx, state, options) => {
          // Gold accent on beat
          if (state.momentHueAlpha > 0.2) {
            ctx.save();
            ctx.globalAlpha = 0.13 * state.momentHueAlpha;
            ctx.fillStyle = 'gold';
            ctx.beginPath();
            ctx.arc(canvas.width/2, canvas.height/2, 120+90*state.momentHueAlpha, 0, 2*Math.PI);
            ctx.fill();
            ctx.restore();
          }
        }
      },
      neve: {
        name: 'Neve EQ',
        sensitivity: 1.2,
        mainColor: ctx => `hsl(15,100%,55%)`,
        beforeDraw: (ctx, state, options) => {
          // Hardware-style blue overlay
          ctx.save();
          ctx.globalAlpha = 0.08 + 0.1*state.momentHueAlpha;
          ctx.fillStyle = "navy";
          ctx.fillRect(0,0,canvas.width,canvas.height);
          ctx.restore();
        }
      },
      ssl: {
        name: 'SSL EQ',
        sensitivity: 1.2,
        mainColor: ctx => `hsl(200,100%,60%)`,
        beforeDraw: (ctx, state, options) => {
          // Blue/grey SSL glow
          ctx.save();
          ctx.globalAlpha = 0.11 + 0.11*state.momentHueAlpha;
          ctx.fillStyle = "#356";
          ctx.fillRect(0,0,canvas.width,canvas.height);
          ctx.restore();
        }
      }
    };

    // --- Modular DrawPreset Function ---
    function drawPreset(presetKey, alpha, hueOffset, t, noiseAmp, lfo){
      const preset = EQ_PRESETS[presetKey];
      if (!preset) return;

      const sens = parseFloat(sensSlider.value) * (preset.sensitivity || 1);
      const bins  = state.dataMid.length;
      const slice = canvas.width/bins;
      const options = {sens, t, lfo, alpha};

      ctx.globalAlpha = alpha * (preset.alpha || 1);

      // Custom draw logic for advanced presets (spectrum)
      if (preset.customDraw) {
        preset.customDraw(ctx, state, options);
        ctx.globalAlpha = 1;
        return;
      }

      // Optional beforeDraw logic (for background or special features)
      if (preset.beforeDraw) preset.beforeDraw(ctx, state, options);

      // Utility functions
      const midVal  = i => state.dataMid[i]/255;
      const sideVal = i => Math.abs(state.dataLeft[i]-state.dataRight[i])/255;

      // Curve drawer with flexible color and dash
      function drawCurve(getVal, color, dash=false){
        ctx.beginPath();
        for(let i=0;i<bins;i++){
          let f = Math.min(getVal(i)*sens,1);
          let x=i*slice, y=canvas.height-f*canvas.height;
          y += (noise1D(i*0.05 + t*0.3)-0.5)*noiseAmp*canvas.height;
          i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
        }
        ctx.lineWidth = 2 * (1 + (Math.random()-0.5)*0.1*lfo);
        ctx.strokeStyle = (typeof color === 'function') ? color(ctx) : color;
        ctx.setLineDash(dash?[4,4]:[]);
        ctx.stroke(); ctx.setLineDash([]);
      }

      // Draw main and side curves
      if (preset.mainColor)
        drawCurve(midVal, preset.mainColor, preset.curveDash);
      if (preset.sideColor)
        drawCurve(sideVal, preset.sideColor, true);

      // Optional afterDraw logic (for restoring context)
      if (preset.afterDraw) preset.afterDraw(ctx);

      ctx.globalAlpha = 1;
    }

    // --- Draw Loop ---
    function draw() {
      requestAnimationFrame(draw);
      state.leftAnalyser.getByteFrequencyData(state.dataLeft);
      state.rightAnalyser.getByteFrequencyData(state.dataRight);
      const binCount = state.dataLeft.length;
      for(let i=0; i<binCount; i++) {
        state.dataMid[i] = (state.dataLeft[i] + state.dataRight[i]) * 0.5;
      }
      const t = (performance.now() - state.startTime)*0.001;
      const hueOffset = (t*5) % 360;
      const lfo = (Math.sin(Math.PI*0.2*t)+1)/2;
      const noiseAmp = 0.02 * (0.5 + 0.5*lfo);

      // Crossfade logic
      if(crossfadeToggle.checked) {
        if(!state.xfadeActive && t > state.nextXfade){
          state.xfadeActive = true; state.xfadeStart = t;
          const all=Object.keys(EQ_PRESETS);
          state.secondaryPreset = all.filter(p=>p!==state.mainPreset)[Math.floor(Math.random()*(all.length-1))];
        }
      } else state.xfadeActive=false;
      let w2=0;
      if(state.xfadeActive) {
        w2=Math.min((t-state.xfadeStart)/state.xfadeDur,1);
        if(w2>=1){
          state.mainPreset=state.secondaryPreset; presetSelect.value=state.mainPreset;
          state.xfadeActive=false;
          state.nextXfade=t+300+Math.random()*300;
          w2=0;
        }
      }
      const w1=1-w2;

      // Beat detection
      const threshold = parseFloat(beatThreshold.value);
      const cooldown  = parseFloat(beatCooldown.value);
      const bassAvg = ((state.dataLeft[2]+state.dataRight[2])/2)/255;
      if(momentsToggle.checked && bassAvg>threshold && t - state.lastBeatTime>cooldown){
        state.lastBeatTime = t;
        state.momentHue = Math.random()*360;
        state.momentHueAlpha = 1;
      }
      state.momentHueAlpha *= 0.9;

      // Tracer
      if(tracerToggle.checked) {
        ctx.fillStyle='rgba(0,0,0,0.15)';
        ctx.fillRect(0,0,canvas.width,canvas.height);
      } else {
        ctx.clearRect(0,0,canvas.width,canvas.height);
      }

      // Band markers
      const freqs=[60,250,1000,4000,16000];
      const nyq=state.audioContext.sampleRate/2;
      const slice=canvas.width/binCount;
      ctx.strokeStyle='rgba(255,255,255,0.2)'; ctx.lineWidth=1;
      ctx.font='12px sans-serif'; ctx.fillStyle='rgba(255,255,255,0.2)';
      freqs.forEach(f=>{
        const b=Math.round(f/nyq*binCount), x=b*slice;
        ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke();
        ctx.fillText(f+'Hz', x+2,14);
      });

      drawPreset(state.mainPreset, w1, hueOffset, t, noiseAmp, lfo);
      if(w2>0) drawPreset(state.secondaryPreset, w2, hueOffset, t, noiseAmp, lfo);
    }

    // --- Fullscreen Button ---
    fsBtn.onclick = ()=> {
      document.fullscreenElement
        ? document.exitFullscreen()
        : canvas.requestFullscreen();
    };

    // --- Auto-hide Controls on Inactivity ---
    let hideT;
    ['pointermove','touchstart','keydown'].forEach(evt=>
      document.addEventListener(evt,()=>{
        controls.style.opacity='1';
        clearTimeout(hideT);
        hideT = setTimeout(()=>controls.style.opacity='0',3000);
      })
    );

    // --- App Init ---
    startBtn.addEventListener('click', startEQ);
    populateDevices();

  </script>
</body>
</html>

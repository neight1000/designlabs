<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Visual EQ Pro v1.18</title>
  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; background: #000; color: #fff; font-family: sans-serif; height: 100vh; width: 100vw; }
    #controls {
      position: absolute; top: 10px; left: 50%;
      transform: translateX(-50%);
      display: flex; flex-wrap: wrap; gap: 8px; align-items: center;
      z-index: 10; transition: opacity .5s;
      background: rgba(0,0,0,0.5); padding: 6px; border-radius: 4px;
    }
    select, button, label, input[type=range] {
      background: #000; color: #fff;
      border: 1px solid #fff; padding: 4px 8px;
      font-size: 1rem;
    }
    label { display: flex; align-items: center; gap: 4px; }
    input[type=range] { width: 80px; }
    canvas { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; display: block; cursor: pointer; }
    @media (max-width:700px) {
      #controls { flex-direction: column; gap: 4px; }
      select, button, label, input[type=range] { font-size: 0.9rem; }
    }
  </style>
</head>
<body>
  <div id="controls" role="form" aria-label="EQ Controls">
    <label for="deviceSelect">Input</label>
    <select id="deviceSelect"></select>
    <button id="startBtn">Start</button>
    <label for="fftSelect">FFT</label>
    <select id="fftSelect">
      <option>256</option><option selected>512</option>
      <option>1024</option><option>2048</option>
      <option>4096</option><option>8192</option>
      <option>16384</option><option>32768</option>
    </select>
    <label for="presetSelect">Preset</label>
    <select id="presetSelect">
      <option value="vhs">VHS Drift</option>
      <option value="tape">Tape Echo</option>
      <option value="neon">Neon Grid</option>
      <option value="aurora">Aurora</option>
      <option value="spectrum">Spectrum Cascade</option>
      <option value="pultec">Pultec EQ</option>
      <option value="neve">Neve EQ</option>
      <option value="ssl">SSL EQ</option>
    </select>
    <label for="sensSlider">Sensitivity
      <input type="range" id="sensSlider" min="0.5" max="3" step="0.05" value="1.15">
    </label>
    <label><input type="checkbox" id="tracerToggle" checked> Tracers</label>
    <label><input type="checkbox" id="crossfadeToggle"> Crossfade</label>
    <label><input type="checkbox" id="momentsToggle"> Moments</label>
    <label for="beatThreshold">Beat Thr
      <input type="range" id="beatThreshold" min="0.1" max="1" step="0.05" value="0.7">
    </label>
    <label for="beatCooldown">Cooldown
      <input type="range" id="beatCooldown" min="0.1" max="2" step="0.1" value="0.3">
    </label>
    <button id="fsBtn">Fullscreen</button>
  </div>
  <canvas id="vis" aria-label="Audio visualizer"></canvas>
  <div id="fallback" style="display:none;position:absolute;top:40%;left:50%;transform:translate(-50%,-50%);color:#f43;font-size:1.1em;background:#222;padding:1em 2em;border-radius:6px;"></div>
  <script>
    // DOM & state
    const $ = id => document.getElementById(id);
    const deviceSelect   = $('deviceSelect'),
          startBtn        = $('startBtn'),
          fftSelect       = $('fftSelect'),
          presetSelect    = $('presetSelect'),
          sensSlider      = $('sensSlider'),
          tracerToggle    = $('tracerToggle'),
          crossfadeToggle = $('crossfadeToggle'),
          momentsToggle   = $('momentsToggle'),
          beatThreshold   = $('beatThreshold'),
          beatCooldown    = $('beatCooldown'),
          fsBtn           = $('fsBtn'),
          controls        = $('controls'),
          canvas          = $('vis'),
          fallback        = $('fallback'),
          ctx             = canvas.getContext('2d');
    const state = {
      audioContext: null,
      splitter: null,
      leftAnalyser: null,
      rightAnalyser: null,
      dataLeft: null,
      dataRight: null,
      dataMid: null,
      startTime: 0,
      mainPreset: presetSelect.value,
      xfadeActive: false,
      xfadeStart: 0,
      xfadeDur: 5,
      nextXfade: 0,
      secondaryPreset: presetSelect.value,
      lastBeatTime: 0,
      momentHue: 0,
      momentHueAlpha: 0,
      spectrumTrails: [],
      dbSmoothed: -60,
      beatTimes: [],
      bpm: 0
    };

    // Helpers
    function fract(x){ return x - Math.floor(x); }
    function rand(n){ return fract(Math.sin(n)*43758.5453123); }
    function noise1D(x){
      const i = Math.floor(x), f = fract(x);
      return rand(i)*(1-f) + rand(i+1)*f;
    }
    function resizeCanvas(){
      canvas.width  = window.innerWidth;
      canvas.height = window.innerHeight;
      state.spectrumTrails = [];
    }
    window.addEventListener('resize', ()=>setTimeout(resizeCanvas,100));
    document.addEventListener('fullscreenchange', resizeCanvas);
    resizeCanvas();

    async function populateDevices(){
      try {
        const devs = await navigator.mediaDevices.enumerateDevices();
        deviceSelect.innerHTML = '';
        devs.filter(d=>d.kind==='audioinput').forEach((d,i)=>{
          const o = document.createElement('option');
          o.value = d.deviceId;
          o.textContent = d.label || `Mic ${i+1}`;
          deviceSelect.append(o);
        });
      } catch(e){
        showFallback('Could not enumerate audio devices.');
      }
    }
    function showFallback(msg){
      fallback.style.display = 'block';
      fallback.textContent = msg;
      controls.style.display = 'none';
      canvas.style.display = 'none';
    }

    // Decibel meter via analyser
    function updateDbMeter(){
      if(!state.leftAnalyser) return;
      const buf = new Float32Array(state.leftAnalyser.fftSize);
      state.leftAnalyser.getFloatTimeDomainData(buf);
      let sum = 0;
      for(let i=0;i<buf.length;i++) sum += buf[i]*buf[i];
      let rms = Math.sqrt(sum/buf.length);
      let db  = 20 * Math.log10(rms || 1e-8);
      if(!isFinite(state.dbSmoothed)) state.dbSmoothed = db;
      state.dbSmoothed = state.dbSmoothed*0.85 + db*0.15;
    }

    async function startEQ(){
      if(state.audioContext) return;
      if(!navigator.mediaDevices?.getUserMedia){
        showFallback('Web Audio API not supported.');
        return;
      }
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          audio: { deviceId: deviceSelect.value||undefined }
        });
        const ac = new (window.AudioContext||window.webkitAudioContext)();
        state.audioContext = ac;
        state.splitter = ac.createChannelSplitter(2);
        state.leftAnalyser = ac.createAnalyser();
        state.rightAnalyser = ac.createAnalyser();
        [state.leftAnalyser, state.rightAnalyser].forEach(a=>{
          a.fftSize = parseInt(fftSelect.value);
          a.smoothingTimeConstant = 0.8;
        });
        state.dataLeft  = new Uint8Array(state.leftAnalyser.frequencyBinCount);
        state.dataRight = new Uint8Array(state.rightAnalyser.frequencyBinCount);
        state.dataMid   = new Uint8Array(state.leftAnalyser.frequencyBinCount);
        const src = ac.createMediaStreamSource(stream);
        src.connect(state.splitter);
        state.splitter.connect(state.leftAnalyser,  0);
        state.splitter.connect(state.rightAnalyser, 1);
        state.startTime = performance.now();
        state.nextXfade = state.startTime/1000 + 300 + Math.random()*300;
        state.spectrumTrails = [];
        draw();
      } catch(e){
        showFallback('Permission denied or no input device found.');
      }
    }
    fftSelect.addEventListener('change', ()=>{
      if(!state.leftAnalyser) return;
      [state.leftAnalyser, state.rightAnalyser].forEach(a=>{
        a.fftSize = parseInt(fftSelect.value);
      });
      state.dataLeft  = new Uint8Array(state.leftAnalyser.frequencyBinCount);
      state.dataRight = new Uint8Array(state.rightAnalyser.frequencyBinCount);
      state.dataMid   = new Uint8Array(state.leftAnalyser.frequencyBinCount);
      state.spectrumTrails = [];
    });
    presetSelect.addEventListener('change', ()=>state.mainPreset = presetSelect.value);

    // Color utilities
    function dynamicHSB(hue, sat, bri, shift=0, alpha=1){
      return `hsla(${(hue+shift)%360},${sat}%,${bri}%,${alpha})`;
    }
    function baseHue(t){
      return ((t*30) + state.momentHue*state.momentHueAlpha)%360;
    }

    // EQ presets definitions (unchanged from v1.17) ...
    // <RETAIN your entire EQ_PRESETS object here>

    // drawPreset (unchanged) except drawCurve mapping:
    function drawPreset(presetKey, alpha, hueOffset, t, noiseAmp, lfo){
      const preset = EQ_PRESETS[presetKey];
      if(!preset) return;
      const sens = parseFloat(sensSlider.value)*(preset.sensitivity||1);
      const bins = state.dataMid.length;
      const sliceY = canvas.height/bins;
      const options = {sens, t, lfo, alpha};

      ctx.globalAlpha = alpha*(preset.alpha||1);
      if(preset.customDraw){
        preset.customDraw(ctx, state, {...options, hueOffset});
        ctx.globalAlpha=1;
        return;
      }
      if(preset.beforeDraw) preset.beforeDraw(ctx, state, {...options, hueOffset});

      const midVal  = i=>state.dataMid[i]/255;
      const sideVal = i=>Math.abs(state.dataLeft[i]-state.dataRight[i])/255;

      function drawCurve(getVal, color, dash=false){
        ctx.beginPath();
        for(let i=0;i<bins;i++){
          let f = Math.min(getVal(i)*sens,1);
          let y = canvas.height - i*sliceY;
          let x = f*canvas.width;
          x += (noise1D(i*0.05 + t*0.3)-0.5)*noiseAmp*canvas.width;
          i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
        }
        ctx.lineWidth = 2*(1 + (Math.random()-0.5)*0.1*lfo);
        ctx.strokeStyle = typeof color==='function'?color(ctx,t):color;
        ctx.setLineDash(dash?[4,4]:[]);
        ctx.stroke(); ctx.setLineDash([]);
      }

      if(preset.mainColor) drawCurve(midVal, preset.mainColor, preset.curveDash);
      if(preset.sideColor) drawCurve(sideVal, preset.sideColor, true);
      if(preset.afterDraw) preset.afterDraw(ctx);
      ctx.globalAlpha =1;
    }

    // Draw dB meter at Y-offset
    function drawDbMeter(offsetY=0){
      const barX = 12,
            barY = offsetY + 12,
            barW = 18,
            barH = canvas.height - barY - 12;
      const minDb = -60, maxDb = 0;
      const db = Math.max(minDb, Math.min(state.dbSmoothed, maxDb));
      const norm = (db - minDb)/(maxDb - minDb);
      ctx.save();
      ctx.globalAlpha = 0.8;
      ctx.fillStyle = '#222';
      ctx.fillRect(barX-3, barY-3, barW+6, barH+6);
      const grad = ctx.createLinearGradient(barX, barY+barH, barX, barY);
      grad.addColorStop(0,'#0f0');
      grad.addColorStop(0.7,'#ff0');
      grad.addColorStop(1,'#f00');
      ctx.fillStyle = grad;
      ctx.fillRect(barX, barY + barH*(1-norm), barW, barH*norm);
      ctx.strokeStyle='#fff'; ctx.lineWidth=1;
      ctx.strokeRect(barX-1, barY-1, barW+2, barH+2);
      ctx.font = 'bold 15px sans-serif';
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'middle';
      ctx.fillText(
        (db>minDb?db.toFixed(1):'--')+' dB',
        barX+barW+10,
        barY + barH*(1-norm)
      );
      ctx.restore();
    }

    // Draw BPM at Y-offset
    function drawBpmMeter(offsetY=0, bpm=0){
      ctx.save();
      ctx.font = 'bold 18px sans-serif';
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'right';
      ctx.textBaseline = 'top';
      ctx.shadowColor = '#000'; ctx.shadowBlur = 5;
      ctx.fillText(
        `BPM: ${bpm>0?Math.round(bpm):'--'}`,
        canvas.width - 24,
        offsetY + 4
      );
      ctx.restore();
    }

    function draw(){
      requestAnimationFrame(draw);
      state.leftAnalyser.getByteFrequencyData(state.dataLeft);
      state.rightAnalyser.getByteFrequencyData(state.dataRight);
      const bins = state.dataLeft.length;
      for(let i=0;i<bins;i++){
        state.dataMid[i] = (state.dataLeft[i] + state.dataRight[i]) * 0.5;
      }
      const t = (performance.now() - state.startTime)*0.001;
      const lfo = (Math.sin(Math.PI*0.2*t)+1)/2;
      const noiseAmp = 0.02 * (0.5 + 0.5*lfo);

      updateDbMeter();

      // Crossfade logic...
      if(crossfadeToggle.checked){
        if(!state.xfadeActive && t>state.nextXfade){
          state.xfadeActive=true; state.xfadeStart=t;
          const all = Object.keys(EQ_PRESETS);
          state.secondaryPreset = all.filter(p=>p!==state.mainPreset)[Math.floor(Math.random()*(all.length-1))];
        }
      } else state.xfadeActive=false;
      let w2 = state.xfadeActive
        ? Math.min((t-state.xfadeStart)/state.xfadeDur,1)
        : 0;
      if(w2>=1){
        state.mainPreset = state.secondaryPreset;
        presetSelect.value = state.mainPreset;
        state.xfadeActive = false;
        state.nextXfade = t + 300 + Math.random()*300;
        w2 = 0;
      }
      const w1 = 1 - w2;

      // Beat detection & BPM
      const threshold = parseFloat(beatThreshold.value),
            cooldown  = parseFloat(beatCooldown.value),
            bassAvg   = ((state.dataLeft[2]+state.dataRight[2])/2)/255;
      if(momentsToggle.checked && bassAvg>threshold && t - state.lastBeatTime>cooldown){
        state.lastBeatTime = t;
        state.momentHue = Math.random()*360;
        state.momentHueAlpha = 1;
        state.beatTimes.push(t);
        if(state.beatTimes.length>8) state.beatTimes.shift();
        if(state.beatTimes.length>=2){
          const intervals = state.beatTimes.slice(1).map((v,i)=>v-state.beatTimes[i]);
          const avg = intervals.reduce((a,b)=>a+b,0)/intervals.length;
          state.bpm = 60/avg;
        } else state.bpm=0;
      }
      state.momentHueAlpha *= 0.9;

      // Tracer / clear
      if(tracerToggle.checked){
        ctx.fillStyle='rgba(0,0,0,0.15)';
        ctx.fillRect(0,0,canvas.width,canvas.height);
      } else {
        ctx.clearRect(0,0,canvas.width,canvas.height);
      }

      // Band markers → horizontal lines
      const freqs=[60,250,1000,4000,16000],
            nyq   = state.audioContext.sampleRate/2;
      ctx.strokeStyle='rgba(255,255,255,0.18)'; ctx.lineWidth=1;
      ctx.font='12px sans-serif'; ctx.fillStyle='rgba(255,255,255,0.22)';
      ctx.textAlign='right';
      freqs.forEach(f=>{
        const y = canvas.height - (f/nyq)*canvas.height;
        ctx.beginPath();
        ctx.moveTo(0,y);
        ctx.lineTo(canvas.width,y);
        ctx.stroke();
        ctx.fillText(f+'Hz', canvas.width-4, y-4);
      });
      ctx.textAlign='left';

      // Draw EQ visuals
      drawPreset(state.mainPreset, w1, (t*5)%360, t, noiseAmp, lfo);
      if(w2>0) drawPreset(state.secondaryPreset, w2, (t*5)%360, t, noiseAmp, lfo);

      // Draw meters below controls
      const ctrlH = controls.getBoundingClientRect().height + 8;
      drawDbMeter(ctrlH);
      drawBpmMeter(ctrlH, state.bpm);
    }

    fsBtn.onclick = ()=> {
      document.fullscreenElement
        ? document.exitFullscreen()
        : canvas.requestFullscreen();
    };
    let hideT;
    ['pointermove','touchstart','keydown'].forEach(evt=>
      document.addEventListener(evt,()=>{
        controls.style.opacity='1';
        clearTimeout(hideT);
        hideT = setTimeout(()=>controls.style.opacity='0',3000);
      })
    );
    startBtn.addEventListener('click', startEQ);
    populateDevices();
  </script>
</body>
</html>

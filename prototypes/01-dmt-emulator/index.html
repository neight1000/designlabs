<script>
const preset = document.getElementById('preset'),
      delay = document.getElementById('delay'),
      echo = document.getElementById('echo'),
      reverb = document.getElementById('reverb'),
      filter = document.getElementById('filter'),
      freq = document.getElementById('freq'),
      volume = document.getElementById('volume'),
      bpmControl = document.getElementById('bpm'),
      density = document.getElementById('density'),
      height = document.getElementById('height'),
      playBtn = document.getElementById('play'),
      stopBtn = document.getElementById('stop'),
      toggleDisplayBtn = document.getElementById('toggleDisplay'),
      infoDisplay = document.getElementById('infoDisplay');
let audioCtx, analyser, masterGain, reverbNode, reverbFeedback, bufferLength, dataArray;
let bpmTimer = null, stopped = true;
let trailFrames = [], currentWaveColor = "#00FF7F";
let canvas, ctx;

const presetSettings = {
  plants:   { scale: [174,285,396,417,528], color:"#00FF7F", slow:1 },
  mold:     { scale: [432,639,741],         color:"#8A2BE2", slow:1 },
  bacteria: { scale: [528,554,585,728],      color:"#FF4500", slow:1 },
  mushrooms:{ scale: [417,444,528,639],      color:"#FFD700", slow:1 },
  harmony:  { scale: [432,528,639,741,852],  color:"#00FFFF", slow:1 },
  dmt:      { scale: [100,140,200,250,310],  color:"#7F00FF", slow:4 }
};

function getScale()   { return presetSettings[preset.value].scale; }
function getColor()   { return presetSettings[preset.value].color; }
function getSlow()    { return presetSettings[preset.value].slow; }

function initAudio(){
  if (audioCtx) return;
  canvas = document.getElementById("waveCanvas");
  ctx = canvas.getContext("2d");
  canvas.width = window.innerWidth; canvas.height = window.innerHeight;
  window.addEventListener("resize", ()=>{ canvas.width = innerWidth; canvas.height = innerHeight; });

  audioCtx = new (window.AudioContext||window.webkitAudioContext)();
  audioCtx.resume();
  analyser = audioCtx.createAnalyser(); analyser.fftSize = 2048;
  bufferLength = analyser.frequencyBinCount; dataArray = new Uint8Array(bufferLength);

  masterGain = audioCtx.createGain(); masterGain.gain.value = parseFloat(volume.value)/100;
  reverbNode = audioCtx.createDelay();
  reverbFeedback = audioCtx.createGain();
  reverbNode.delayTime = 0.4; 
  // Cap the reverb feedback value to prevent ringing
  reverbFeedback.gain.value = Math.min(Math.max(parseFloat(reverb.value), 0), 0.35); 
  // Add a mellowing filter on reverb feedback loop
  const reverbLPF = audioCtx.createBiquadFilter();
  reverbLPF.type = "lowpass";
  reverbLPF.frequency.value = 2400;

  reverbNode.connect(reverbLPF);
  reverbLPF.connect(reverbFeedback);
  reverbFeedback.connect(reverbNode);
  reverbNode.connect(masterGain);
  masterGain.connect(audioCtx.destination);

  canvas = document.getElementById("waveCanvas");
  ctx = canvas.getContext("2d");
  animate();
}

function playTone(freqVal){
  if (!audioCtx) initAudio();
  const now = audioCtx.currentTime;
  const slow = getSlow();

  // Soft filter for all tones
  const filterNode = audioCtx.createBiquadFilter();
  filterNode.type = "lowpass";
  filterNode.frequency.value = Math.min(parseFloat(filter.value), 3000);

  // Delay/Echo, feedback capped to 0.4
  const delayNode = audioCtx.createDelay();
  delayNode.delayTime = parseFloat(delay.value);
  const feedbackNode = audioCtx.createGain();
  feedbackNode.gain.value = Math.min(Math.max(parseFloat(echo.value), 0), 0.4);

  // Feedback path mellowed with a lowpass filter
  const echoLPF = audioCtx.createBiquadFilter();
  echoLPF.type = "lowpass";
  echoLPF.frequency.value = 1800;
  
  // Envelope softened
  const gainNode = audioCtx.createGain();
  gainNode.gain.setValueAtTime(0, now);
  gainNode.gain.linearRampToValueAtTime(0.18, now + 0.4*slow);
  gainNode.gain.linearRampToValueAtTime(0, now + 2.5*slow);

  // dry path
  gainNode.connect(masterGain);
  gainNode.connect(analyser);

  const panNode = audioCtx.createStereoPanner();
  panNode.pan.value = Math.random()*2-1;

  [-0.5,0,0.5].forEach(offset=>{
    const osc = audioCtx.createOscillator();
    osc.type = "triangle"; // mellow, less harsh than "square"
    osc.frequency.value = freqVal*(1+offset/100);
    const pitchLFO = audioCtx.createOscillator();
    const pitchLFOGain = audioCtx.createGain();
    pitchLFO.frequency.value = 0.18;
    pitchLFOGain.gain.value = 1.1;
    pitchLFO.connect(pitchLFOGain).connect(osc.frequency);
    pitchLFO.start(now); pitchLFO.stop(now + 2.5*slow);
    osc.connect(gainNode);
    osc.start(now); osc.stop(now + 2.5*slow);
  });

  gainNode.connect(panNode);
  panNode.connect(filterNode);
  filterNode.connect(delayNode);

  delayNode.connect(echoLPF);
  echoLPF.connect(feedbackNode);
  feedbackNode.connect(delayNode);

  delayNode.connect(reverbNode);
}

function scheduleNotes(){
  clearInterval(bpmTimer);
  const scale = getScale();
  const interval = 60000 / parseInt(bpmControl.value) * getSlow();
  bpmTimer = setInterval(()=>{
    if (!stopped) playTone(scale[Math.floor(Math.random()*scale.length)]);
  }, interval);
}

function animate(){
  if (!ctx || !analyser) return;
  requestAnimationFrame(animate);
  analyser.getByteTimeDomainData(dataArray);
  ctx.fillStyle="rgba(0,0,0,0.05)";
  ctx.fillRect(0,0,canvas.width,canvas.height);
  if (trailFrames.length>12) trailFrames.shift();
  trailFrames.push([...dataArray]);

  const grad = ctx.createLinearGradient(0,0,canvas.width,0);
  grad.addColorStop(0, getColor());
  grad.addColorStop(1, "#32cd32");

  const dens = parseInt(density.value);
  const step = Math.max(1, Math.floor(bufferLength/(dens*20)));
  const hf = parseFloat(height.value);

  trailFrames.forEach((data,t)=>{
    ctx.beginPath();
    let x=0, slice=canvas.width/(data.length/step);
    for (let i=0;i<data.length;i+=step){
      const v=(data[i]-128)/128;
      const y=v*(canvas.height/2*0.9*hf)+canvas.height/2;
      i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
      x+=slice;
    }
    ctx.strokeStyle=grad;
    ctx.globalAlpha=0.05+(t/trailFrames.length)*0.1;
    ctx.shadowBlur=16; ctx.shadowColor=getColor(); ctx.stroke();
    ctx.shadowBlur=0; ctx.globalAlpha=1;
  });

  ctx.save();
  ctx.globalAlpha=0.1;
  ctx.translate(canvas.width/2,canvas.height/2);
  ctx.scale(0.98,0.98);
  ctx.translate(-canvas.width/2,-canvas.height/2);
  ctx.drawImage(canvas,0,0);
  ctx.restore();
}

playBtn.addEventListener("click", ()=>{
  initAudio();
  stopped = false;
  bpm = parseInt(bpmControl.value);
  currentWaveColor = getColor();
  // immediate first tone
  const scale = getScale();
  playTone(scale[Math.floor(Math.random()*scale.length)]);
  scheduleNotes();
});

stopBtn.addEventListener("click", ()=>{
  stopped = true;
  clearInterval(bpmTimer);
});

bpmControl.addEventListener("input", ()=>{
  bpm = parseInt(bpmControl.value);
  if (!stopped) scheduleNotes();
});

preset.addEventListener("change", ()=>{
  currentWaveColor = getColor();
  if (!stopped) scheduleNotes();
});

reverb.addEventListener("input", ()=>{
  if (reverbFeedback) reverbFeedback.gain.value = Math.min(Math.max(parseFloat(reverb.value), 0), 0.35);
});

toggleDisplayBtn.addEventListener("click", ()=>{
  infoDisplay.style.display = infoDisplay.style.display==="none"?"block":"none";
});

function updateDisplay(){
  infoDisplay.textContent =
    `PRESET: ${preset.value}\nDELAY: ${delay.value}\nECHO: ${echo.value}\nREVERB: ${reverb.value}\nFILTER: ${filter.value}\nFREQ: ${freq.value}\nVOLUME: ${volume.value}\nBPM: ${bpm}\nDENSITY:${density.value}\nHEIGHT:${height.value}`;
}
setInterval(updateDisplay,250);
</script>

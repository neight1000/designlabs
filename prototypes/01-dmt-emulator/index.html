<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Plantasia x SP-12 â€“ 12-bit Drum Machine Emu (Ambient Synth)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body { margin: 0; padding: 0; background: #111; color: white; font-family: monospace; overflow: hidden; }
    canvas { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 0; display: block; }
    .ui { position: absolute; bottom: 0; width: 100%; background: rgba(0, 0, 0, 0.85); padding: 10px; display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; z-index: 2; }
    .ui label { font-size: 10px; display: block; text-align: center; }
    .ui input[type="range"], .ui select { width: 90px; }
    .ui button { font-size: 12px; padding: 4px 8px; background: transparent; border: 1px solid white; color: white; cursor: pointer; }
    #infoDisplay { position: absolute; top: 10px; left: 10px; z-index: 3; background: rgba(0, 0, 0, 0.6); color: white; font-size: 12px; padding: 10px; display: none; white-space: pre; }
  </style>
</head>
<body>
<canvas id="waveCanvas"></canvas>
<div id="infoDisplay"></div>
<div class="ui">
  <div><label>Preset</label>
    <select id="preset">
      <option value="plants">Plants</option>
      <option value="mold">Mold</option>
      <option value="bacteria">Bacteria</option>
      <option value="mushrooms">Mushrooms</option>
      <option value="harmony">Lifeform Harmony</option>
      <option value="sp12" selected>SP-12 Drum</option>
    </select>
  </div>
  <div><label>Volume</label><input type="range" id="volume" min="0" max="100" value="65" /></div>
  <button id="play">PLAY</button>
  <button id="stop">STOP</button>
  <button id="toggleDisplay">TOGGLE DATA</button>
</div>
<script>
// Audio setup
let audioCtx, masterGain, stopped = true, animId;
const noteIntervals = {plants: 4000, mold: 4500, bacteria: 600, mushrooms: 3000, harmony: 5000, sp12: 700};
const presetSettings = {
  plants: {
    scale: [174, 196, 220, 246, 261, 293, 329], // Pentatonic, ascending
    envelope: {attack:0.3, decay:2.5, sustain:0.15, release:3.5},
    color: "#00FF7F",
    visual: "plants"
  },
  mold: {
    scale: [220, 233, 246, 261, 277, 293, 311], // Chromatic cluster
    envelope: {attack:1.5, decay:2, sustain:0.2, release:4},
    color: "#8A2BE2",
    visual: "mold"
  },
  bacteria: {
    scale: [440, 445, 493, 523, 550, 570, 600], // Microtonal
    envelope: {attack:0.01, decay:0.08, sustain:0.01, release:0.05},
    color: "#FF4500",
    visual: "bacteria"
  },
  mushrooms: {
    scale: [220, 330, 415, 660, 880], // Harmonic, bell-like
    envelope: {attack:0.5, decay:3, sustain:0.1, release:2.5},
    color: "#FFD700",
    visual: "mushrooms"
  },
  harmony: {
    scale: [174, 261, 329, 392, 523, 659, 783], // Chordal
    envelope: {attack:2, decay:8, sustain:0.25, release:7},
    color: "#00FFFF",
    visual: "harmony"
  },
  sp12: {
    scale: [55, 110, 220, 440, 880],
    envelope: {attack:0.01, decay:0.3, sustain:0.01, release:0.2},
    color: "#B5A642",
    visual: "sp12"
  }
};
// Visual setup
const canvas = document.getElementById("waveCanvas");
const ctx = canvas.getContext("2d");
function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

let visuals = {plants:[], mold:[], bacteria:[], mushrooms:[], harmony:[], sp12:[]};
function resetVisuals(preset) {
  visuals = {plants:[], mold:[], bacteria:[], mushrooms:[], harmony:[], sp12:[]};
  if (preset === "plants") visuals.plants = [{x:canvas.width/2, y:canvas.height, len:0, angle:Math.PI*1.5, growth:2, branches:[]}];
  if (preset === "mold") visuals.mold = [{x:canvas.width/2, y:canvas.height/2, r:10, a:0}];
  if (preset === "bacteria") visuals.bacteria = [];
  if (preset === "mushrooms") visuals.mushrooms = [];
  if (preset === "harmony") visuals.harmony = [];
  if (preset === "sp12") visuals.sp12 = [];
}

// Play logic
function envNode(ctx, params) {
  const g = ctx.createGain();
  const now = ctx.currentTime;
  g.gain.setValueAtTime(0, now);
  g.gain.linearRampToValueAtTime(1, now+params.attack);
  g.gain.linearRampToValueAtTime(params.sustain, now+params.attack+params.decay);
  g.gain.linearRampToValueAtTime(0, now+params.attack+params.decay+params.release);
  setTimeout(()=>g.disconnect(), (params.attack+params.decay+params.release)*1000 + 200);
  return g;
}
function playAmbientSynth(preset) {
  if (!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
  if (!masterGain) {
    masterGain = audioCtx.createGain();
    masterGain.gain.value = parseFloat(document.getElementById('volume').value) / 100;
    masterGain.connect(audioCtx.destination);
  }
  if (stopped) return;
  const setting = presetSettings[preset];
  let freq = setting.scale[Math.floor(Math.random()*setting.scale.length)];
  // Plant: drift upward, Mold: drift downward, Bacteria: random, Mushrooms: detune, Harmony: chord, SP12: retro
  if (preset==="plants") freq += Math.random()*10;
  if (preset==="mold") freq -= Math.random()*6;
  if (preset==="bacteria") freq += (Math.random()-0.5)*30;
  if (preset==="mushrooms") freq *= [1,1.25,1.5][Math.floor(Math.random()*3)];
  // Harmony: play chord
  if (preset==="harmony") {
    const chord = [0,2,4].map(i=>setting.scale[(Math.floor(Math.random()*setting.scale.length)+i)%setting.scale.length]);
    chord.forEach(f=>{
      const o = audioCtx.createOscillator();
      o.type = ["triangle","sine"][Math.floor(Math.random()*2)];
      o.frequency.value = f;
      const g = envNode(audioCtx, setting.envelope);
      o.connect(g).connect(masterGain);
      o.start();
      o.stop(audioCtx.currentTime+setting.envelope.attack+setting.envelope.decay+setting.envelope.release);
    });
  } else {
    const osc = audioCtx.createOscillator();
    if (preset==="sp12") osc.type = ["square","triangle","sawtooth"][Math.floor(Math.random()*3)];
    else osc.type = ["sine","triangle","sawtooth"][Math.floor(Math.random()*3)];
    osc.frequency.value = freq;
    if (preset==="mushrooms") osc.detune.value = Math.random()*20-10;
    const g = envNode(audioCtx, setting.envelope);
    osc.connect(g).connect(masterGain);
    osc.start();
    osc.stop(audioCtx.currentTime+setting.envelope.attack+setting.envelope.decay+setting.envelope.release);
  }
}
// Animation logic
function animate(preset) {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  const color = presetSettings[preset].color;
  if (preset==="plants") {
    // Draw growing vines
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    visuals.plants.forEach(stem=>{
      ctx.save();
      ctx.translate(stem.x, stem.y);
      ctx.rotate(stem.angle);
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.lineTo(0,-stem.len);
      ctx.stroke();
      ctx.restore();
      stem.len += stem.growth;
      if (stem.len>100+Math.random()*120 && stem.branches.length<2) {
        stem.branches.push({x:stem.x+Math.sin(stem.angle+0.3)*stem.len, y:stem.y-Math.cos(stem.angle+0.3)*stem.len, len:0, angle:stem.angle+0.3, growth:2+Math.random()*1.5, branches:[]});
        stem.branches.push({x:stem.x+Math.sin(stem.angle-0.3)*stem.len, y:stem.y-Math.cos(stem.angle-0.3)*stem.len, len:0, angle:stem.angle-0.3, growth:2+Math.random()*1.5, branches:[]});
      }
    });
    visuals.plants = visuals.plants.concat(visuals.plants.flatMap(s=>s.branches));
    if (visuals.plants.length>30) visuals.plants = visuals.plants.slice(-30);
  }
  if (preset==="mold") {
    // Mold: soft growing blobs
    visuals.mold.forEach(col=>{
      ctx.beginPath();
      ctx.arc(col.x, col.y, col.r, 0, Math.PI*2);
      ctx.strokeStyle = color;
      ctx.globalAlpha = 0.25;
      ctx.fillStyle = color;
      ctx.fill();
      ctx.globalAlpha = 1;
      ctx.stroke();
      col.r += 0.27 + Math.random()*0.26;
      if (col.r > 40+Math.random()*40 && visuals.mold.length<12) {
        visuals.mold.push({
          x:col.x+Math.random()*140-70,
          y:col.y+Math.random()*140-70,
          r:5+Math.random()*5,
          a:0
        });
      }
    });
    if (visuals.mold.length>20) visuals.mold = visuals.mold.slice(-20);
  }
  if (preset==="bacteria") {
    // Bacteria: dots that divide/move
    if (Math.random()<0.2 || visuals.bacteria.length<10) {
      visuals.bacteria.push({
        x:Math.random()*canvas.width,
        y:Math.random()*canvas.height,
        dx:(Math.random()-0.5)*2,
        dy:(Math.random()-0.5)*2,
        r:2+Math.random()*2,
        age:0
      });
    }
    visuals.bacteria.forEach(b=>{
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fillStyle = color;
      ctx.globalAlpha = 0.7;
      ctx.fill();
      ctx.globalAlpha = 1;
      b.x += b.dx;
      b.y += b.dy;
      b.age++;
    });
    visuals.bacteria = visuals.bacteria.filter(b=>b.age<100);
  }
  if (preset==="mushrooms") {
    // Mushrooms: draw blooming caps
    if (Math.random()<0.07) {
      visuals.mushrooms.push({
        x:Math.random()*canvas.width,
        y:canvas.height-20,
        r:5,
        maxr:40+Math.random()*30,
        growing:true
      });
    }
    visuals.mushrooms.forEach(m=>{
      ctx.beginPath();
      ctx.arc(m.x, m.y, m.r, Math.PI, 2*Math.PI);
      ctx.fillStyle = color;
      ctx.globalAlpha = 0.8;
      ctx.fill();
      ctx.globalAlpha = 1;
      if (m.growing) m.r += 0.7;
      if (m.r>=m.maxr) m.growing=false;
      if (!m.growing) m.r -= 0.15;
    });
    visuals.mushrooms = visuals.mushrooms.filter(m=>m.r>5);
  }
  if (preset==="harmony") {
    // Harmony: luminous overlapping circles
    if (visuals.harmony.length<7 && Math.random()<0.1) {
      visuals.harmony.push({
        x:Math.random()*canvas.width,
        y:Math.random()*canvas.height,
        r:20+Math.random()*40,
        alpha:0.7+Math.random()*0.2,
        grow:0.7+Math.random(),
        age:0
      });
    }
    visuals.harmony.forEach(c=>{
      ctx.beginPath();
      ctx.arc(c.x, c.y, c.r, 0, Math.PI*2);
      ctx.strokeStyle = color;
      ctx.globalAlpha = c.alpha;
      ctx.stroke();
      ctx.globalAlpha = 1;
      c.r += c.grow;
      c.alpha *= 0.99;
      c.age++;
    });
    visuals.harmony = visuals.harmony.filter(c=>c.alpha>0.06 && c.r<canvas.width/2);
  }
  if (preset==="sp12") {
    // SP12: retro bars
    if (Math.random()<0.23) {
      visuals.sp12.push({
        x:Math.random()*canvas.width,
        w:10+Math.random()*40,
        h:10+Math.random()*80,
        y:canvas.height-Math.random()*50,
        alpha:0.6+Math.random()*0.2
      });
    }
    visuals.sp12.forEach(b=>{
      ctx.fillStyle = color;
      ctx.globalAlpha = b.alpha;
      ctx.fillRect(b.x, b.y-b.h, b.w, b.h);
      ctx.globalAlpha = 1;
      b.alpha *= 0.95;
    });
    visuals.sp12 = visuals.sp12.filter(b=>b.alpha>0.05);
  }
  animId = requestAnimationFrame(()=>animate(preset));
}
// Scheduling logic
let synthTimer = null;
function startAmbientSynth(preset) {
  stopped = false;
  resetVisuals(preset);
  function schedule() {
    if (stopped) return;
    playAmbientSynth(preset);
    synthTimer = setTimeout(schedule, noteIntervals[preset]);
  }
  schedule();
  animate(preset);
}
function stopAmbientSynth() {
  stopped = true;
  clearTimeout(synthTimer);
  if (animId) cancelAnimationFrame(animId);
}
// UI
document.getElementById('play').addEventListener('click', async () => {
  if (!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
  if (!masterGain) {
    masterGain = audioCtx.createGain();
    masterGain.gain.value = parseFloat(document.getElementById('volume').value) / 100;
    masterGain.connect(audioCtx.destination);
  }
  const preset = document.getElementById('preset').value;
  stopAmbientSynth();
  startAmbientSynth(preset);
});
document.getElementById('stop').addEventListener('click', () => stopAmbientSynth());
document.getElementById('preset').addEventListener('change', () => {
  stopAmbientSynth();
  resetVisuals(document.getElementById('preset').value);
});
document.getElementById('volume').addEventListener('input', e => {
  if (masterGain) masterGain.gain.value = parseFloat(e.target.value) / 100;
});
// Display
const display = document.getElementById("infoDisplay");
document.getElementById("toggleDisplay").addEventListener("click", () => {
  display.style.display = display.style.display === "none" ? "block" : "none";
});
function updateDisplay() {
  const preset = document.getElementById("preset").value;
  display.textContent =
    "PRESET      : " + preset + "\n" +
    "COLOR       : " + presetSettings[preset].color + "\n" +
    "NOTES       : " + presetSettings[preset].scale.map(x=>x+" Hz").join(", ") + "\n" +
    "VOLUME      : " + document.getElementById("volume").value + "\n";
}
setInterval(updateDisplay, 350);
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Plantasia x SP-12 – 12-bit Drum Machine Emu</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    html, body { margin:0; padding:0; background:black; color:white; font-family:monospace; overflow:hidden; }
    canvas { position:absolute; top:0; left:0; width:100vw; height:100vh; z-index:0; }
    .ui { position:absolute; bottom:0; width:100%; background:rgba(0,0,0,0.85); padding:10px; display:flex; flex-wrap:wrap; justify-content:center; gap:10px; z-index:2; }
    .ui label{ font-size:10px; text-align:center; display:block; }
    .ui input[type=range], .ui select{ width:90px; }
    .ui button{ font-size:12px; padding:4px 8px; background:transparent; border:1px solid white; color:white; cursor:pointer; }
    #infoDisplay{ position:absolute; top:10px; left:10px; z-index:3; background:rgba(0,0,0,0.6); color:white; font-size:12px; padding:10px; display:none; white-space:pre; }
  </style>
</head>
<body>
  <canvas id="waveCanvas"></canvas>
  <div id="infoDisplay"></div>
  <div class="ui">
    <div><label>Preset</label>
      <select id="preset">
        <option value="plants">Plants</option>
        <option value="mold">Mold</option>
        <option value="bacteria">Bacteria</option>
        <option value="mushrooms">Mushrooms</option>
        <option value="harmony">Lifeform Harmony</option>
        <option value="sp12" selected>SP-12 Drum</option>
      </select>
    </div>
    <div><label>12-bit</label><input type="checkbox" id="bitcrush" checked/></div>
    <div><label>Downsample</label><input type="range" id="downsample" min="8000" max="48000" step="1000" value="26000"/></div>
    <div><label>Filter</label><input type="range" id="filter" min="100" max="8000" step="10" value="1500"/></div>
    <div><label>Resonance</label><input type="range" id="resonance" min="0.1" max="20" step="0.1" value="6.0"/></div>
    <div><label>Pitch Drift</label><input type="range" id="pitchDrift" min="0" max="0.1" step="0.001" value="0.07"/></div>
    <div><label>Volume</label><input type="range" id="volume" min="0" max="100" value="65"/></div>
    <div><label>BPM</label><input type="range" id="bpm" min="40" max="180" value="90"/></div>
    <div><label>Tape Sat</label><input type="range" id="tapeSat" min="0" max="1" step="0.01" value="0.18"/></div>
    <button id="play">PLAY</button>
    <button id="stop">STOP</button>
    <button id="toggleDisplay">TOGGLE DATA</button>
  </div>
  <script>
    // Element refs
    const preset     = document.getElementById('preset');
    const bitcrush   = document.getElementById('bitcrush');
    const downsample = document.getElementById('downsample');
    const filterCtrl = document.getElementById('filter');
    const resonance  = document.getElementById('resonance');
    const pitchDrift = document.getElementById('pitchDrift');
    const volumeCtrl = document.getElementById('volume');
    const bpmCtrl    = document.getElementById('bpm');
    const tapeSat    = document.getElementById('tapeSat');
    const playBtn    = document.getElementById('play');
    const stopBtn    = document.getElementById('stop');
    const toggleDisp = document.getElementById('toggleDisplay');
    const infoDisp   = document.getElementById('infoDisplay');

    // UI state on load
    playBtn.disabled = false;
    stopBtn.disabled = true;

    // State
    let audioCtx, analyser, masterGain, filterNode, bitcrusherNode, tapeNode;
    let convolver, compressor, lfo, lfoGain;
    let isAudioInitialized = false;
    let stopped = true;
    let bpm = 90, bpmTimer;
    const loadedSamples = {};
    const trailFrames = [];
    let canvas, ctx, bufferLength, dataArray;
    let currentWaveColor = "#B5A642";

    // Preset data
    const presetSettings = {
      plants:   { color:"#00FF7F", samples:["https://cdn.jsdelivr.net/gh/joshwcomeau/beatmaker-assets/kick.wav"] },
      mold:     { color:"#8A2BE2", samples:["https://cdn.jsdelivr.net/gh/joshwcomeau/beatmaker-assets/snare.wav"] },
      bacteria: { color:"#FF4500", samples:["https://cdn.jsdelivr.net/gh/joshwcomeau/beatmaker-assets/hihat.wav"] },
      mushrooms:{ color:"#FFD700", samples:["https://cdn.jsdelivr.net/gh/joshwcomeau/beatmaker-assets/clap.wav"] },
      harmony:  { color:"#00FFFF", samples:["https://cdn.jsdelivr.net/gh/joshwcomeau/beatmaker-assets/tom.wav"] },
      sp12:     { color:"#B5A642", samples:[
        "https://cdn.jsdelivr.net/gh/joshwcomeau/beatmaker-assets/kick.wav",
        "https://cdn.jsdelivr.net/gh/joshwcomeau/beatmaker-assets/snare.wav",
        "https://cdn.jsdelivr.net/gh/joshwcomeau/beatmaker-assets/hihat.wav"
      ]}
    };

    function getColor(val)   { return presetSettings[val]?.color   || "#FFF"; }
    function getSamples(val) { return presetSettings[val]?.samples || []; }

    // Canvas resize
    function resizeCanvas() {
      if (!canvas) return;
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);

    // Load samples with caching
    async function loadSamples(name) {
      const urls = getSamples(name);
      if (loadedSamples[name]) return;
      loadedSamples[name] = {};
      await Promise.all(urls.map(async url => {
        const resp = await fetch(url);
        const buf  = await resp.arrayBuffer();
        loadedSamples[name][url] = await audioCtx.decodeAudioData(buf);
      }));
    }

    // Bitcrusher via AudioWorklet or fallback to gain (with UI disable)
    async function loadBitcrusher() {
      if (audioCtx.audioWorklet) {
        const code = `
          class BitCrusherProcessor extends AudioWorkletProcessor {
            static get parameterDescriptors() {
              return [
                { name:'bitDepth', defaultValue:12, minValue:1, maxValue:16 },
                { name:'frequency', defaultValue:26000, minValue:8000, maxValue:48000 }
              ];
            }
            constructor(){ super(); this.phase=0; this.last=0; }
            process(ins, outs, params){
              const input = ins[0], output = outs[0];
              const bits = params.bitDepth.length===1 ? params.bitDepth[0] : params.bitDepth;
              const freq = params.frequency.length===1 ? params.frequency[0] : params.frequency;
              const step = Math.pow(0.5, bits);
              const rate = sampleRate / freq;
              for(let ch=0; ch<input.length; ch++){
                for(let i=0; i<input[ch].length; i++){
                  this.phase++;
                  if(this.phase >= rate){
                    this.phase -= rate;
                    this.last = Math.round(input[ch][i]/step)*step;
                  }
                  output[ch][i] = this.last;
                }
              }
              return true;
            }
          }
          registerProcessor('bitcrusher', BitCrusherProcessor);
        `;
        const blob = new Blob([code], { type:'application/javascript' });
        await audioCtx.audioWorklet.addModule(URL.createObjectURL(blob));
        bitcrusherNode = new AudioWorkletNode(audioCtx, 'bitcrusher');
        bitcrush.disabled = false;
        downsample.disabled = false;
      } else {
        // Fallback is just a gain node, disables the UI for these
        bitcrusherNode = audioCtx.createGain();
        bitcrush.disabled = true;
        downsample.disabled = true;
      }
    }

    // Tape saturation
    function makeSatCurve(amount=0.18) {
      const n = 44100, curve = new Float32Array(n);
      for(let i=0; i<n; i++){
        const x = (i*2)/n - 1;
        curve[i] = Math.tanh(x * (1 + amount*10));
      }
      return curve;
    }
    function createTapeNode(amount) {
      const ws = audioCtx.createWaveShaper();
      ws.curve = makeSatCurve(amount);
      ws.oversample = '4x';
      return ws;
    }

    // Initialize everything (only once)
    async function initAudio() {
      if (isAudioInitialized) return;

      // AudioContext + resume
      audioCtx = new (window.AudioContext||window.webkitAudioContext)();
      await audioCtx.resume();

      // Analyzer
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 2048;
      bufferLength = analyser.frequencyBinCount;
      dataArray = new Uint8Array(bufferLength);

      // Canvas
      canvas = document.getElementById('waveCanvas');
      ctx    = canvas.getContext('2d');
      resizeCanvas();

      // Core nodes
      masterGain = audioCtx.createGain();
      masterGain.gain.value = parseFloat(volumeCtrl.value)/100;

      filterNode = audioCtx.createBiquadFilter();
      filterNode.type = 'lowpass';
      filterNode.frequency.value = parseFloat(filterCtrl.value);
      filterNode.Q.value         = parseFloat(resonance.value);

      await loadBitcrusher();
      tapeNode = createTapeNode(parseFloat(tapeSat.value));

      // Main chain: filter → bitcrusher → tape → master
      filterNode.connect(bitcrusherNode);
      bitcrusherNode.connect(tapeNode);
      tapeNode.connect(masterGain);

      // Tap for visuals & final output
      masterGain.connect(analyser);
      masterGain.connect(audioCtx.destination);

      // Convolver (reverb)
      convolver = audioCtx.createConvolver();
      fetch('https://cdn.jsdelivr.net/gh/joshwcomeau/beatmaker-assets/drum-room-ir.wav')
        .then(r=>r.arrayBuffer())
        .then(b=>audioCtx.decodeAudioData(b))
        .then(buf=>convolver.buffer = buf);
      masterGain.connect(convolver);
      convolver.connect(audioCtx.destination);

      // Parallel compressor
      compressor = audioCtx.createDynamicsCompressor();
      compressor.threshold.value = -24;
      compressor.knee.value      = 30;
      compressor.ratio.value     = 4;
      compressor.attack.value    = 0.001;
      compressor.release.value   = 0.2;
      masterGain.connect(compressor);
      compressor.connect(audioCtx.destination);

      // LFO → filter cutoff
      lfo = audioCtx.createOscillator();
      lfoGain = audioCtx.createGain();
      lfo.type = 'sine';
      lfo.frequency.value = 0.15;
      lfoGain.gain.value  = 600;
      lfo.connect(lfoGain).connect(filterNode.frequency);
      lfo.start();

      isAudioInitialized = true;
      animate();
    }

    // Play one sample
    function playSample() {
      const urls = getSamples(preset.value);
      if (!urls.length) return;
      const url = urls[Math.floor(Math.random()*urls.length)];
      const buffer = loadedSamples[preset.value][url];
      if (!buffer) return;

      const src = audioCtx.createBufferSource();
      src.buffer = buffer;
      src.playbackRate.value = 1 + ((Math.random()-0.5)*0.04);

      const pan = audioCtx.createStereoPanner();
      pan.pan.value = (Math.random()*2 - 1) * 0.5;
      src.connect(pan).connect(filterNode);

      // Sub-kick under kicks, disconnect after done
      if (url.includes('kick.wav')) {
        const sub = audioCtx.createOscillator();
        const env = audioCtx.createGain();
        sub.type = 'sine';
        sub.frequency.value = 60;
        sub.connect(env).connect(filterNode);
        const now = audioCtx.currentTime;
        env.gain.setValueAtTime(0, now);
        env.gain.linearRampToValueAtTime(0.2, now + 0.01);
        env.gain.exponentialRampToValueAtTime(0.0001, now + 0.3);
        sub.onended = () => {
          sub.disconnect();
          env.disconnect();
        };
        sub.start(now);
        sub.stop(now + 0.3);
      }

      const jitter = (Math.random() - 0.5) * 0.02;
      src.start(audioCtx.currentTime + jitter);
    }

    // Schedule loop
    function scheduleNotes() {
      clearInterval(bpmTimer);
      bpmTimer = setInterval(() => {
        if (!stopped) playSample();
      }, 60000 / bpm);
    }

    // Draw waveform
    function animate() {
      requestAnimationFrame(animate);
      analyser.getByteTimeDomainData(dataArray);
      ctx.fillStyle = 'rgba(0,0,0,0.08)';
      ctx.fillRect(0,0,canvas.width,canvas.height);

      if (trailFrames.length > 12) trailFrames.shift();
      trailFrames.push([...dataArray]);

      const grad = ctx.createLinearGradient(0,0,canvas.width,0);
      grad.addColorStop(0, currentWaveColor);
      grad.addColorStop(1, '#000');

      trailFrames.forEach((data, t) => {
        const slice = canvas.width / data.length;
        ctx.beginPath();
        data.forEach((v,i) => {
          const x = i * slice;
          const y = ((v - 128) / 128) * (canvas.height/2 * 0.9) + canvas.height/2;
          i === 0 ? ctx.moveTo(x,y) : ctx.lineTo(x,y);
        });
        ctx.globalAlpha = 0.05 + (t / trailFrames.length)*0.1;
        ctx.strokeStyle = grad;
        ctx.shadowBlur = 16;
        ctx.shadowColor = currentWaveColor;
        ctx.stroke();
        ctx.shadowBlur = 0;
        ctx.globalAlpha = 1;
      });
    }

    // UI Events
    playBtn.addEventListener('click', async () => {
      if (!stopped) return;
      playBtn.disabled = true;
      stopBtn.disabled = false;
      stopped = false;
      currentWaveColor = getColor(preset.value);
      await initAudio();
      if (audioCtx.state === 'suspended') await audioCtx.resume();
      await loadSamples(preset.value);
      bpm = parseInt(bpmCtrl.value);
      scheduleNotes();
      playSample();
    });

    stopBtn.addEventListener('click', async () => {
      stopped = true;
      clearInterval(bpmTimer);
      if (audioCtx) await audioCtx.suspend();
      playBtn.disabled = false;
      stopBtn.disabled = true;
    });

    bpmCtrl.addEventListener('input', e => { bpm = parseInt(e.target.value); if (!stopped) scheduleNotes(); });
    preset.addEventListener('change', async () => { currentWaveColor = getColor(preset.value); await loadSamples(preset.value); });
    filterCtrl.addEventListener('input', e => filterNode.frequency.value = parseFloat(e.target.value));
    resonance.addEventListener('input', e => filterNode.Q.value = parseFloat(e.target.value));
    downsample.addEventListener('input', e => bitcrusherNode.parameters?.get('frequency') && (bitcrusherNode.parameters.get('frequency').value = parseFloat(e.target.value)));
    bitcrush.addEventListener('change', e => bitcrusherNode.parameters?.get('bitDepth') && (bitcrusherNode.parameters.get('bitDepth').value = e.target.checked?12:16));
    volumeCtrl.addEventListener('input', e => masterGain.gain.value = parseFloat(e.target.value)/100);
    tapeSat.addEventListener('input', () => tapeNode.curve = makeSatCurve(parseFloat(tapeSat.value)));
    toggleDisp.addEventListener('click', () => {
      infoDisp.style.display = infoDisp.style.display === 'none' ? 'block' : 'none';
    });

    // Display params
    setInterval(() => {
      infoDisp.textContent =
        `PRESET      : ${preset.value}\n` +
        `BITCRUSH    : ${bitcrush.checked?'12-bit':'16-bit'}\n` +
        `DOWNSAMPLE  : ${downsample.value} Hz\n` +
        `FILTER      : ${filterCtrl.value}\n` +
        `RESONANCE   : ${resonance.value}\n` +
        `TAPE SAT    : ${tapeSat.value}\n` +
        `PITCH DRIFT : ${pitchDrift.value}\n` +
        `VOLUME      : ${volumeCtrl.value}\n` +
        `BPM         : ${bpmCtrl.value}`;
    }, 250);
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Visual EQ v1.11</title>
  <style>
    html, body {
      margin: 0; padding: 0; overflow: hidden;
      background: #000; color: #fff;
      font-family: sans-serif;
      height: 100vh; width: 100vw;
    }
    #controls {
      position: absolute; top: 10px; left: 50%;
      transform: translateX(-50%);
      display: flex; gap: 8px; align-items: center;
      z-index: 10; transition: opacity 0.5s;
      background: rgba(0,0,0,0.5); padding: 6px; border-radius: 4px;
    }
    select, button, label, input[type=range] {
      background: #000; color: #fff;
      border: 1px solid #fff; padding: 4px 8px;
      font-size: 1rem;
    }
    label { display: flex; align-items: center; gap: 4px; }
    input[type=range] { width: 100px; }
    canvas {
      position: absolute; top: 0; left: 0;
      width: 100vw; height: 100vh;
    }
  </style>
</head>
<body>
  <div id="controls">
    <select id="deviceSelect"></select>
    <button id="startBtn">Start</button>
    <select id="fftSelect">
      <option>256</option><option selected>512</option>
      <option>1024</option><option>2048</option>
      <option>4096</option><option>8192</option>
      <option>16384</option><option>32768</option>
    </select>
    <select id="presetSelect">
      <option value="vhs">VHS Drift</option>
      <option value="tape">Tape Echo</option>
      <option value="neon">Neon Grid</option>
      <option value="aurora">Aurora</option>
      <option value="spectrum">Spectrum Cascade</option>
      <option value="pultec">Pultec EQ</option>
      <option value="neve">Neve EQ</option>
      <option value="ssl">SSL EQ</option>
    </select>
    <label>Sensitivity
      <input type="range" id="sensSlider" min="0.5" max="3" step="0.05" value="1.15">
    </label>
    <label><input type="checkbox" id="tracerToggle" checked> Tracers</label>
    <label><input type="checkbox" id="crossfadeToggle"> Crossfade</label>
    <label><input type="checkbox" id="momentsToggle"> Moments</label>
    <button id="fsBtn">Fullscreen</button>
  </div>
  <canvas id="vis"></canvas>

  <script>
    const deviceSelect   = document.getElementById('deviceSelect'),
          startBtn        = document.getElementById('startBtn'),
          fftSelect       = document.getElementById('fftSelect'),
          presetSelect    = document.getElementById('presetSelect'),
          sensSlider      = document.getElementById('sensSlider'),
          tracerToggle    = document.getElementById('tracerToggle'),
          crossfadeToggle = document.getElementById('crossfadeToggle'),
          momentsToggle   = document.getElementById('momentsToggle'),
          fsBtn           = document.getElementById('fsBtn'),
          controls        = document.getElementById('controls'),
          canvas          = document.getElementById('vis'),
          ctx             = canvas.getContext('2d');

    let audioContext, splitter, leftAnalyser, rightAnalyser, dataLeft, dataRight, startTime;
    let mainPreset = presetSelect.value;
    let xfadeActive = false, xfadeStart = 0, xfadeDur = 5, nextXfade = 0;
    let secondaryPreset = mainPreset;
    let lastBeatTime = 0, momentHue = 0, momentHueAlpha = 0;

    // noise helper
    function fract(x){ return x - Math.floor(x); }
    function rand(n){ return fract(Math.sin(n)*43758.5453123); }
    function noise1D(x){
      const i = Math.floor(x), f = fract(x);
      return rand(i)*(1-f) + rand(i+1)*f;
    }

    function resizeCanvas(){
      canvas.width  = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    document.addEventListener('fullscreenchange', resizeCanvas);
    resizeCanvas();

    async function populateDevices(){
      const devs = await navigator.mediaDevices.enumerateDevices();
      devs.filter(d=>d.kind==='audioinput').forEach((d,i)=>{
        const o = document.createElement('option');
        o.value = d.deviceId;
        o.textContent = d.label || `Mic ${i+1}`;
        deviceSelect.append(o);
      });
    }

    async function startEQ(){
      if(audioContext) return;
      const stream = await navigator.mediaDevices.getUserMedia({
        audio: { deviceId: deviceSelect.value||undefined, channelCount:2 }
      });
      audioContext = new (window.AudioContext||window.webkitAudioContext)();
      splitter = audioContext.createChannelSplitter(2);
      leftAnalyser = audioContext.createAnalyser();
      rightAnalyser = audioContext.createAnalyser();
      leftAnalyser.fftSize = rightAnalyser.fftSize = parseInt(fftSelect.value);
      leftAnalyser.smoothingTimeConstant = rightAnalyser.smoothingTimeConstant = 0.8;
      dataLeft = new Uint8Array(leftAnalyser.frequencyBinCount);
      dataRight = new Uint8Array(rightAnalyser.frequencyBinCount);
      const src = audioContext.createMediaStreamSource(stream);
      src.connect(splitter);
      splitter.connect(leftAnalyser, 0);
      splitter.connect(rightAnalyser, 1);
      startTime = performance.now();
      nextXfade = startTime/1000 + 300 + Math.random()*300;
      draw();
    }

    fftSelect.addEventListener('change', ()=>{
      if(!leftAnalyser) return;
      leftAnalyser.fftSize = rightAnalyser.fftSize = parseInt(fftSelect.value);
      dataLeft = new Uint8Array(leftAnalyser.frequencyBinCount);
      dataRight = new Uint8Array(rightAnalyser.frequencyBinCount);
    });

    presetSelect.addEventListener('change', ()=>{ mainPreset = presetSelect.value; });

    function draw(){
      requestAnimationFrame(draw);
      leftAnalyser.getByteFrequencyData(dataLeft);
      rightAnalyser.getByteFrequencyData(dataRight);

      const t = (performance.now()-startTime)*0.001;
      const hueOffset = (t*5)%360;
      const lfo = (Math.sin(2*Math.PI*0.1*t)+1)/2; // 0.1 Hz LFO
      const noiseAmpBase = 0.02 * (0.5 + 0.5*lfo);

      // crossfade logic...
      if(crossfadeToggle.checked){
        if(!xfadeActive && t > nextXfade){
          xfadeActive = true;
          xfadeStart = t;
          secondaryPreset = ['vhs','tape','neon','aurora','spectrum','pultec','neve','ssl']
            .filter(p=>p!==mainPreset)[Math.floor(Math.random()*7)];
        }
      } else xfadeActive = false;
      let w2=0;
      if(xfadeActive){
        w2 = Math.min((t - xfadeStart)/xfadeDur,1);
        if(w2>=1){
          mainPreset = secondaryPreset;
          presetSelect.value = mainPreset;
          xfadeActive = false;
          nextXfade = t + 300 + Math.random()*300;
          w2 = 0;
        }
      }
      const w1 = 1 - w2;

      // beat detection mid band
      let bassL = dataLeft[2], bassR = dataRight[2];
      const bassAvg = (bassL + bassR)/2/255;
      if(momentsToggle.checked && bassAvg>0.7 && t - lastBeatTime>0.3){
        lastBeatTime = t;
        momentHue = Math.random()*360;
        momentHueAlpha = 1;
      }
      momentHueAlpha *= 0.9;

      // tracer
      if(tracerToggle.checked){
        ctx.fillStyle = 'rgba(0,0,0,0.15)';
        ctx.fillRect(0,0,canvas.width,canvas.height);
      } else {
        ctx.clearRect(0,0,canvas.width,canvas.height);
      }

      // band markers
      const freqs = [60,250,1000,4000,16000];
      const bins = leftAnalyser.frequencyBinCount;
      const nyq = audioContext.sampleRate/2;
      const slice = canvas.width/bins;
      ctx.strokeStyle='rgba(255,255,255,0.2)'; ctx.lineWidth=1;
      ctx.font='12px sans-serif'; ctx.fillStyle='rgba(255,255,255,0.2)';
      freqs.forEach(f=>{
        const b = Math.round(f/nyq*bins), x=b*slice;
        ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke();
        ctx.fillText(f+'Hz', x+2, 14);
      });

      // draw presets
      drawPreset(mainPreset, w1, hueOffset, t, noiseAmpBase);
      if(w2>0) drawPreset(secondaryPreset, w2, hueOffset, t, noiseAmpBase);
    }

    function drawPreset(preset, alpha, hueOffset, t, noiseAmp){
      const sens = parseFloat(sensSlider.value);
      const bins = leftAnalyser.frequencyBinCount;
      const slice = canvas.width/bins;
      const jitter = 1 + (Math.random()-0.5)*0.1*lfo;
      ctx.globalAlpha = alpha;

      const getMid = i => (dataLeft[i] + dataRight[i]) / 2 / 255;
      const getSide = i => Math.abs(dataLeft[i] - dataRight[i]) / 255;

      // draw mid (solid) and side (dashed) curves
      function drawCurve(getVal, color, dash=false){
        ctx.beginPath();
        for(let i=0;i<bins;i++){
          const f = Math.min(getVal(i)*sens,1);
          let x = i*slice, y = canvas.height - f*canvas.height;
          y += (noise1D(i*0.05 + t*0.3)-0.5)*noiseAmp*canvas.height;
          i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
        }
        ctx.lineWidth = 2*jitter;
        ctx.strokeStyle = color;
        ctx.setLineDash(dash?[4,4]:[]);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      const dynHue = base => (base + hueOffset + momentHue*momentHueAlpha)%360;

      switch(preset){
        case 'vhs':
          drawCurve(i=>getMid(i), `hsla(${dynHue(0)},0%,80%,${alpha})`);
          drawCurve(i=>getSide(i), `hsla(${dynHue(0)},0%,50%,${alpha})`, true);
          break;
        case 'tape':
          ctx.shadowBlur = 30; ctx.shadowColor = `hsla(${dynHue(200)},100%,80%,${alpha})`;
          drawCurve(i=>getMid(i), `hsla(${dynHue(200)},100%,80%,${alpha*0.7})`);
          ctx.shadowBlur = 0; ctx.globalAlpha = alpha;
          drawCurve(i=>getSide(i), `hsla(${dynHue(200)},100%,50%,${alpha})`, true);
          break;
        case 'neon':
          drawCurve(i=>getMid(i), `hsla(${dynHue(180)},100%,60%,${alpha})`);
          drawCurve(i=>getSide(i), `hsla(${dynHue(180)},100%,30%,${alpha})`, true);
          break;
        case 'aurora':
          ctx.fillStyle = ctx.createLinearGradient(0,0,0,canvas.height);
          ctx.fillStyle.addColorStop(0,'#081d71');
          ctx.fillStyle.addColorStop(0.5,'#20ff90');
          ctx.fillStyle.addColorStop(1,'#081d71');
          ctx.globalAlpha = alpha*0.5;
          drawCurve(i=>getMid(i), ctx.fillStyle);
          ctx.globalAlpha = alpha;
          drawCurve(i=>getSide(i), `hsla(${dynHue(120)},100%,50%,${alpha})`, true);
          break;
        case 'spectrum':
          for(let i=0;i<bins;i++){
            const f = Math.min(getMid(i)*sens,1);
            const x = i*slice;
            const h = (i/bins*360 + hueOffset)%360;
            const barH = f*canvas.height;
            ctx.fillStyle = `hsl(${h},100%,60%)`;
            ctx.fillRect(x, canvas.height-barH, slice, barH);
          }
          break;
        case 'pultec':
          ctx.lineJoin = 'round';
          drawCurve(i=>getMid(i), `hsla(${dynHue(30)},100%,60%,${alpha})`);
          break;
        case 'neve':
          drawCurve(i=>getMid(i), `hsla(${dynHue(15)},100%,55%,${alpha})`);
          break;
        case 'ssl':
          drawCurve(i=>getMid(i), `hsla(${dynHue(200)},100%,60%,${alpha})`);
          break;
      }

      ctx.globalAlpha = 1;
    }

    fsBtn.onclick = ()=>{
      document.fullscreenElement
        ? document.exitFullscreen()
        : canvas.requestFullscreen();
    };
    ['pointermove','touchstart','keydown'].forEach(e=>
      document.addEventListener(e,()=>{
        controls.style.opacity='1';
        clearTimeout(this.hideT);
        this.hideT=setTimeout(()=>controls.style.opacity='0',3000);
      })
    );

    startBtn.addEventListener('click', startEQ);
    populateDevices();
  </script>
</body>
</html>

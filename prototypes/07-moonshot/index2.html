<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Moonshot Hybrid - Full Production</title>
<link href="https://fonts.googleapis.com/css2?family=Roboto+Mono&display=swap" rel="stylesheet">
<style>
  body {
    margin: 0;
    background: #000;
    color: #fff;
    font-family: 'Roboto Mono', monospace;
    overflow: hidden;
  }
  #gameCanvas {
    display: block;
    margin: 0 auto;
    background: linear-gradient(#111, #000);
    border: 4px solid #0f0;
  }
  #score {
    position: absolute;
    top: 10px;
    left: 10px;
    font-size: 20px;
    color: #0f0;
  }
  #titleScreen {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: rgba(0, 0, 0, 0.95);
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    font-size: 30px;
  }
  button {
    font-family: 'Roboto Mono', monospace;
    font-size: 20px;
    margin-top: 20px;
    padding: 10px 30px;
    cursor: pointer;
    border: 2px solid #fff;
    background: #000;
    color: #fff;
  }
  button:hover {
    background: #222;
  }
</style>
</head>
<body>

<div id="score">Score: 0</div>
<canvas id="gameCanvas" width="400" height="600"></canvas>
<div id="titleScreen">
  <div>ðŸŒ™ Moonshot Hybrid</div>
  <button onclick="startGame()">Start Game</button>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let grid, player, blocks, bullets, explosions, score, gameRunning, dropCounter = 0;

const cols = 10;
const rows = 20;
const cellSize = 40;
const dropInterval = 30;
const colors = ['#ff0000','#ffa500','#ffff00','#00ff00','#00ffff','#0000ff','#ff00ff'];

function initGame() {
  grid = Array.from({ length: rows }, () => Array(cols).fill(0));
  player = { x: 4, length: 1 };
  blocks = [];
  bullets = [];
  explosions = [];
  score = 0;
  gameRunning = true;
  document.getElementById('score').innerText = 'Score: 0';
  spawnBlock();
  requestAnimationFrame(gameLoop);
}

function spawnBlock() {
  blocks.push({ x: Math.floor(Math.random() * cols), y: 0, frame: 0 });
}

function drawGrid() {
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      if (grid[r][c]) {
        ctx.fillStyle = '#444';
        ctx.fillRect(c * cellSize, r * cellSize, cellSize-2, cellSize-2);
      }
    }
  }
}

function drawPlayer() {
  ctx.fillStyle = '#0f0';
  for (let i = 0; i < player.length; i++) {
    ctx.beginPath();
    ctx.moveTo((player.x+i)*cellSize+20, (rows-1)*cellSize+5);
    ctx.lineTo((player.x+i)*cellSize+5, (rows-1)*cellSize+35);
    ctx.lineTo((player.x+i)*cellSize+35, (rows-1)*cellSize+35);
    ctx.closePath();
    ctx.fill();
  }
}

function drawBlocks() {
  blocks.forEach(b => {
    ctx.fillStyle = '#ff0';
    ctx.fillRect(b.x * cellSize + 10, b.y * cellSize + 5, 20, 20);
    ctx.fillStyle = '#000';
    ctx.fillRect(b.x * cellSize + 14, b.y * cellSize + 10, 4, 4);
    ctx.fillRect(b.x * cellSize + 22, b.y * cellSize + 10, 4, 4);
    ctx.fillRect(b.x * cellSize + 14, b.y * cellSize + 20, 12, 2);
  });
}

function drawBullets() {
  bullets.forEach(b => {
    for (let i = 0; i < colors.length; i++) {
      ctx.fillStyle = colors[i];
      ctx.fillRect(b.x * cellSize + 18, b.y + i*2, 4, 2);
    }
  });
}

function drawExplosions() {
  explosions.forEach(ex => {
    ctx.fillStyle = ex.color;
    ctx.beginPath();
    ctx.arc(ex.x, ex.y, ex.size, 0, 2*Math.PI);
    ctx.fill();
  });
}

function updateBlocks() {
  dropCounter++;
  if (dropCounter >= dropInterval) {
    dropCounter = 0;
    blocks.forEach(b => b.y++);
  }

  blocks.forEach(b => {
    if (b.y >= rows) {
      grid[rows-1][b.x] = 1;
      b.remove = true;
    } else if (grid[b.y][b.x]) {
      grid[b.y-1][b.x] = 1;
      b.remove = true;
    }
  });
  blocks = blocks.filter(b => !b.remove);
  if (blocks.length === 0) spawnBlock();
}

function updateBullets() {
  bullets.forEach(b => b.y -= 10);
  bullets = bullets.filter(b => b.y > 0);

  bullets.forEach(b => {
    blocks.forEach(bl => {
      if (Math.abs(b.x - bl.x) < 1 && b.y <= bl.y * cellSize + cellSize) {
        bl.remove = true;
        b.hit = true;
        score += 10;
        document.getElementById('score').innerText = 'Score: ' + score;
        explosions.push({ x: bl.x * cellSize + 20, y: bl.y * cellSize + 20, size: 5, color: '#ff0' });
        player.length = Math.min(player.length + 1, cols - player.x);
      }
    });
  });
  bullets = bullets.filter(b => !b.hit);
  blocks = blocks.filter(bl => !bl.remove);
}

function updateExplosions() {
  explosions.forEach(ex => ex.size += 1);
  explosions = explosions.filter(ex => ex.size < 20);
}

function checkRows() {
  for (let r = rows - 1; r >= 0; r--) {
    if (grid[r].every(cell => cell)) {
      grid.splice(r, 1);
      grid.unshift(Array(cols).fill(0));
      score += 50;
      document.getElementById('score').innerText = 'Score: ' + score;
    }
  }
}

function gameLoop() {
  if (!gameRunning) return;
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawGrid();
  drawBlocks();
  drawPlayer();
  drawBullets();
  drawExplosions();
  updateBlocks();
  updateBullets();
  updateExplosions();
  checkRows();
  if (grid[0].some(cell => cell)) gameRunning = false;
  else requestAnimationFrame(gameLoop);
}

document.addEventListener('keydown', e => {
  if (!gameRunning) return;
  if (e.key === 'ArrowLeft' && player.x > 0) player.x--;
  if (e.key === 'ArrowRight' && player.x + player.length < cols) player.x++;
  if (e.key === ' ' || e.key === 'Spacebar') {
    bullets.push({ x: player.x + Math.floor(player.length/2), y: (rows - 1) * cellSize });
  }
});

function startGame() {
  document.getElementById('titleScreen').style.display = 'none';
  initGame();
}
</script>

</body>
</html>

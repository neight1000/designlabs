<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Moonshot Hybrid - Nexus Edition</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
<style>
  /* your full CSS from previous code here (unchanged) */
  /* I'm skipping re-pasting to save space */
</style>
</head>
<body>
<div id="gameContainer">
  <canvas id="gameCanvas" width="900" height="700"></canvas>
  <!-- your UI and overlay screens from previous code -->
  <!-- also skipping here since you have this already -->
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// full gameState object (same as your previous code)
// full ENEMY_TYPES object (same as your previous code)

// (all your existing functions stay unchanged up to checkCollisions)

function checkCollisions() {
  // Player bullets vs enemies
  gameState.bullets.forEach((bullet, bulletIndex) => {
    if (bullet.owner !== 'player') return;
    gameState.enemies.forEach((enemy, enemyIndex) => {
      if (bullet.x < enemy.x + enemy.width &&
          bullet.x + bullet.width > enemy.x &&
          bullet.y < enemy.y + enemy.height &&
          bullet.y + bullet.height > enemy.y) {
        enemy.health -= bullet.damage;
        gameState.bullets.splice(bulletIndex, 1);
        createParticle(enemy.x + enemy.width/2, enemy.y + enemy.height/2, '#ffff00');
        if (enemy.health <= 0) {
          gameState.score += enemy.points * gameState.combo;
          gameState.combo = Math.min(gameState.combo + 0.1, 5);
          createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2, enemy.width);
          if (Math.random() < 0.3) {
            spawnPowerUp(enemy.x + enemy.width/2, enemy.y + enemy.height/2);
          }
          gameState.enemies.splice(enemyIndex, 1);
          playSound(300 + Math.random() * 200, 0.3, 'sawtooth', 0.1);
        }
      }
    });
  });
  
  // Enemy bullets vs player
  gameState.bullets.forEach((bullet, bulletIndex) => {
    if (bullet.owner !== 'enemy') return;
    const p = gameState.player;
    if (bullet.x < p.x + p.width && bullet.x + bullet.width > p.x &&
        bullet.y < p.y + p.height && bullet.y + bullet.height > p.y) {
      if (p.invulnerable <= 0) {
        p.health--;
        p.invulnerable = 60;
        gameState.combo = 1;
        if (p.health <= 0) {
          gameState.lives--;
          if (gameState.lives <= 0) {
            endGame();
          } else {
            p.health = p.maxHealth;
          }
        }
        playSound(100, 0.2, 'sine', 0.2);
      }
      gameState.bullets.splice(bulletIndex, 1);
    }
  });
  
  // Powerups vs player
  gameState.powerUps.forEach((powerUp, powerIndex) => {
    const p = gameState.player;
    if (powerUp.x + 20 > p.x && powerUp.x < p.x + p.width &&
        powerUp.y + 20 > p.y && powerUp.y < p.y + p.height) {
      switch (powerUp.type) {
        case 'multishot':
        case 'rapid':
        case 'laser':
          p.weapon = powerUp.type;
          p.weaponTimer = 300;
          break;
        case 'health':
          if (p.health < p.maxHealth) p.health++;
          break;
      }
      gameState.powerUps.splice(powerIndex, 1);
      playSound(600, 0.2, 'triangle', 0.2);
    }
  });
}

function gameLoop() {
  if (!gameState.gameRunning) return;

  gameState.time++;
  updateBackground();
  updatePlayer();
  updateEnemies();
  updateBullets();
  updatePowerUps();
  updateParticles();
  updateExplosions();
  checkCollisions();

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawStars();
  drawPlayer();
  drawEnemies();
  drawBullets();
  drawPowerUps();
  drawParticles();
  drawExplosions();

  if (gameState.enemies.length === 0 && gameState.waveComplete === false) {
    gameState.waveComplete = true;
    setTimeout(() => {
      gameState.currentWave++;
      spawnWave();
      updateUI();
    }, 1500);
  }

  if (gameState.player.weaponTimer === 0) {
    gameState.player.weapon = 'normal';
  }

  updateUI();

  if (gameState.screenShake > 0) {
    gameState.screenShake--;
    const shakeX = (Math.random() - 0.5) * 10;
    const shakeY = (Math.random() - 0.5) * 10;
    canvas.style.transform = `translate(${shakeX}px, ${shakeY}px)`;
  } else {
    canvas.style.transform = 'translate(0, 0)';
  }

  requestAnimationFrame(gameLoop);
}

function startGame() {
  document.getElementById('titleScreen').style.display = 'none';
  document.getElementById('gameOverScreen').style.display = 'none';
  initGame();
  gameState.gameRunning = true;
  spawnWave();
  requestAnimationFrame(gameLoop);
}

function endGame() {
  gameState.gameRunning = false;
  document.getElementById('finalScore').textContent = `Final Score: ${gameState.score}`;
  document.getElementById('gameOverScreen').style.display = 'flex';
}

function restartGame() {
  startGame();
}

function goToTitle() {
  document.getElementById('titleScreen').style.display = 'flex';
  document.getElementById('gameOverScreen').style.display = 'none';
}

document.addEventListener('keydown', e => {
  gameState.keys[e.key] = true;
});

document.addEventListener('keyup', e => {
  gameState.keys[e.key] = false;
});

</script>
</body>
</html>

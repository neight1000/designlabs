<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Bauhaus Gravity Generator (Confetti & Sound)</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
body { font-family: 'Helvetica Neue', Arial, sans-serif; background: #fff; color: #000; overflow: hidden; height: 100vh; display: flex; flex-direction: column;}
.header { background: #000; color: #fff; padding: 20px; text-align: center; font-weight: 300; letter-spacing: 2px; font-size: 18px; text-transform: uppercase;}
.controls { background: #f5f5f5; padding: 15px 20px; border-bottom: 1px solid #000; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px;}
.control-group { display: flex; align-items: center; gap: 15px;}
.click-counter { font-size: 14px; font-weight: bold; padding: 8px 12px; border: 1px solid #000; background: #fff; min-width: 120px; text-align: center; transition: background 0.3s;}
.btn { background: #000; color: #fff; border: none; padding: 8px 16px; font-size: 12px; text-transform: uppercase; letter-spacing: 1px; cursor: pointer; transition: all 0.2s;}
.btn:hover { background: #333;}
.legend { font-size: 11px; text-transform: uppercase; letter-spacing: 1px;}
.slider-group { display: flex; align-items: center; gap: 10px; background: #fff; padding: 8px 12px; border: 1px solid #000;}
.slider-group label { font-size: 11px; text-transform: uppercase; letter-spacing: 1px; min-width: 60px;}
.slider { width: 100px; height: 4px; background: #ddd; border: none;}
.slider::-webkit-slider-thumb { appearance: none; width: 16px; height: 16px; background: #000; cursor: pointer; border-radius: 0;}
.slider::-moz-range-thumb { width: 16px; height: 16px; background: #000; cursor: pointer; border-radius: 0; border: none;}
.slider-value { font-size: 11px; min-width: 30px; text-align: center;}
.toggle-switch { display: flex; align-items: center; gap: 8px; font-size: 11px; text-transform: uppercase; letter-spacing: 1px; user-select: none;}
.toggle-switch input[type="checkbox"] { width: 36px; height: 18px; appearance: none; background: #ccc; outline: none; border-radius: 9px; position: relative; transition: background 0.2s; cursor: pointer;}
.toggle-switch input[type="checkbox"]:checked { background: #0197F6;}
.toggle-switch input[type="checkbox"]::before { content: ""; position: absolute; left: 2px; top: 2px; width: 14px; height: 14px; background: #fff; border-radius: 50%; transition: transform 0.2s;}
.toggle-switch input[type="checkbox"]:checked::before { transform: translateX(18px);}
#canvas { flex: 1; display: block; cursor: crosshair; background: #fff; border: none;}
.footer { background: #000; color: #fff; padding: 10px 20px; text-align: center; font-size: 10px; text-transform: uppercase; letter-spacing: 1px;}
.shape-preview { width: 20px; height: 20px; border: 1px solid #000; display: inline-block; margin-left: 5px;}
.shape-preview.square { background: #000;}
.shape-preview.triangle { background: linear-gradient(45deg, #000 50%, transparent 50%);}
.shape-preview.circle { border-radius: 50%; background: #000;}
.sound-toggle { margin-left: 16px; }
</style>
</head>
<body>
<div class="header">Bauhaus Gravity Generator</div>
<div class="controls">
    <div class="control-group">
        <div class="click-counter" id="clickCounter">Clicks: 0</div>
        <div class="legend">
            1 Click: Square <div class="shape-preview square"></div>
            2 Clicks: Triangle <div class="shape-preview triangle"></div>
            3 Clicks: Circle <div class="shape-preview circle"></div>
        </div>
    </div>
    <div class="control-group">
        <div class="slider-group">
            <label for="gravitySlider">Gravity:</label>
            <input type="range" id="gravitySlider" class="slider" min="0" max="1" step="0.01" value="0.3">
            <span class="slider-value" id="gravityValue">0.30</span>
        </div>
        <div class="slider-group">
            <label for="dampingSlider">Damping:</label>
            <input type="range" id="dampingSlider" class="slider" min="0.85" max="0.99" step="0.01" value="0.95">
            <span class="slider-value" id="dampingValue">0.95</span>
        </div>
        <div class="toggle-switch">
            <label for="colorToggle">Color Cycle</label>
            <input type="checkbox" id="colorToggle"/>
        </div>
        <div class="toggle-switch sound-toggle">
            <label for="soundToggle">Sound</label>
            <input type="checkbox" id="soundToggle" checked/>
        </div>
    </div>
    <div class="control-group">
        <button class="btn" onclick="clearCanvas()">Clear</button>
        <button class="btn" onclick="saveImage()">Save</button>
    </div>
</div>
<canvas id="canvas"></canvas>
<div class="footer">
    Physics-Based Gravity | Confetti | Sound | Bauhaus Shapes
</div>
<!-- Audio files (must be in same folder as your HTML) -->
<audio id="popSound" src="pop.mp3" preload="auto"></audio>
<audio id="ambientSound" src="ambient.mp3" preload="auto" loop></audio>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const clickCounter = document.getElementById('clickCounter');
const gravitySlider = document.getElementById('gravitySlider');
const gravityValue = document.getElementById('gravityValue');
const dampingSlider = document.getElementById('dampingSlider');
const dampingValue = document.getElementById('dampingValue');
const colorToggle = document.getElementById('colorToggle');
const soundToggle = document.getElementById('soundToggle');
const popSound = document.getElementById('popSound');
const ambientSound = document.getElementById('ambientSound');

let clickCount = 0;
let shapes = [];
let confettiParticles = [];
let animationId = null;
const COLORS = ["#D7263D", "#02182B", "#0197F6", "#FBB13C", "#56A902", "#8F3985", "#B4DFE5", "#FDE74C"];
let colorCycling = false;
let GRAVITY = parseFloat(gravitySlider.value);
let DAMPING = parseFloat(dampingSlider.value);

let soundEnabled = true;

function startAmbient() {
    if (soundEnabled) {
        ambientSound.volume = 0.3;
        ambientSound.play().catch(()=>{});
    }
}
function stopAmbient() {
    ambientSound.pause();
    ambientSound.currentTime = 0;
}
soundToggle.addEventListener('change', function () {
    soundEnabled = this.checked;
    if (soundEnabled) {
        startAmbient();
    } else {
        stopAmbient();
    }
});
canvas.addEventListener('mousedown', function () {
    if (soundEnabled && ambientSound.paused) startAmbient();
});

gravitySlider.addEventListener('input', function () {
    GRAVITY = parseFloat(this.value);
    gravityValue.textContent = GRAVITY.toFixed(2);
});
dampingSlider.addEventListener('input', function () {
    DAMPING = parseFloat(this.value);
    dampingValue.textContent = DAMPING.toFixed(2);
});
colorToggle.addEventListener('change', function () {
    colorCycling = this.checked;
    shapes.forEach((shape, i) => {
        shape.color = colorCycling ? COLORS[i % COLORS.length] : "#000";
    });
});

function getShapeType(clickNum) {
    const clickMod = clickNum % 3;
    return clickMod === 1 ? "square" : clickMod === 2 ? "triangle" : "circle";
}

function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight - canvas.getBoundingClientRect().top - 40;
    rescaleShapes();
}
window.addEventListener('resize', function() {
    resizeCanvas();
});
resizeCanvas();

function calculateOptimalShapeSize() {
    if (shapes.length === 0) return 80;
    const W = canvas.width, H = canvas.height;
    const n = shapes.length;
    let cols = Math.ceil(Math.sqrt(n * W / H));
    let rows = Math.ceil(n / cols);
    let sizeX = W / cols;
    let sizeY = H / rows;
    let size = Math.min(sizeX, sizeY) * 0.88;
    return Math.max(30, size);
}

function rescaleShapes() {
    let newSize = calculateOptimalShapeSize();
    for (let s of shapes) {
        s.targetSize = newSize;
    }
}

function createShape(x, y, type, color) {
    let size = calculateOptimalShapeSize();
    return {
        x: x - size / 2,
        y: y - size / 2,
        vx: (Math.random() - 0.5) * 2,
        vy: Math.random() * -2,
        size: size,
        targetSize: size,
        type: type,
        color: color,
        rotation: (type !== "circle") ? (Math.random() - 0.5) * 0.2 : 0,
        rotationSpeed: (type !== "circle") ? (Math.random() - 0.5) * 0.03 : 0,
        mass: size * 0.007,
        settled: false
    };
}

function drawShape(shape) {
    ctx.save();
    ctx.translate(shape.x + shape.size/2, shape.y + shape.size/2);
    ctx.rotate(shape.rotation || 0);
    ctx.globalAlpha = shape.settled ? 0.95 : 1.0;
    ctx.fillStyle = shape.color;
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 2;
    switch (shape.type) {
        case "square":
            ctx.fillRect(-shape.size/2, -shape.size/2, shape.size, shape.size);
            ctx.strokeRect(-shape.size/2 + 1, -shape.size/2 + 1, shape.size - 2, shape.size - 2);
            break;
        case "triangle":
            ctx.beginPath();
            ctx.moveTo(0, -shape.size/2);
            ctx.lineTo(-shape.size/2, shape.size/2);
            ctx.lineTo(shape.size/2, shape.size/2);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            break;
        case "circle":
            ctx.beginPath();
            ctx.arc(0, 0, shape.size/2, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
            break;
    }
    ctx.restore();
}

// Confetti code
function spawnConfetti(x, y, color) {
    const N = 36;
    for (let i = 0; i < N; i++) {
        let angle = Math.random() * 2 * Math.PI;
        let speed = 3 + Math.random() * 4;
        let size = 5 + Math.random() * 8;
        let c = colorCycling ? COLORS[Math.floor(Math.random() * COLORS.length)] : color;
        confettiParticles.push({
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            size: size,
            color: c,
            life: 36 + Math.random() * 22,
            alpha: 1.0,
            gravity: 0.21 + Math.random() * 0.08
        });
    }
}

function updateConfetti() {
    for (let i = confettiParticles.length - 1; i >= 0; i--) {
        let p = confettiParticles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += p.gravity;
        p.life--;
        p.alpha *= 0.97;
        if (p.life <= 0) confettiParticles.splice(i, 1);
    }
}

function drawConfetti() {
    for (let p of confettiParticles) {
        ctx.save();
        ctx.globalAlpha = Math.max(0, Math.min(1, p.alpha));
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, 2 * Math.PI);
        ctx.fill();
        ctx.restore();
    }
}

// Collision resolution with minimum separation margin
function resolveCollisions() {
    const separationMargin = 0.08;
    for (let i = 0; i < shapes.length; i++) {
        let s = shapes[i];
        for (let j = i + 1; j < shapes.length; j++) {
            let o = shapes[j];
            let dx = (s.x + s.size/2) - (o.x + o.size/2);
            let dy = (s.y + s.size/2) - (o.y + o.size/2);
            let dist = Math.sqrt(dx * dx + dy * dy);
            let minDist = (s.size + o.size) / 2 * (1 + separationMargin);
            if (dist < minDist && dist > 0) {
                // Minimum translation vector
                let overlap = minDist - dist;
                let nx = dx / dist;
                let ny = dy / dist;
                let totalMass = s.mass + o.mass;
                let pushS = (overlap * (o.mass / totalMass));
                let pushO = (overlap * (s.mass / totalMass));
                s.x += nx * pushS;
                s.y += ny * pushS;
                o.x -= nx * pushO;
                o.y -= ny * pushO;
                // Exchange velocities (elastic, but damped)
                let tx = -ny, ty = nx;
                let dpTan1 = s.vx * tx + s.vy * ty;
                let dpTan2 = o.vx * tx + o.vy * ty;
                let dpNorm1 = s.vx * nx + s.vy * ny;
                let dpNorm2 = o.vx * nx + o.vy * ny;
                let m1 = (dpNorm1 * (s.mass - o.mass) + 2 * o.mass * dpNorm2) / totalMass;
                let m2 = (dpNorm2 * (o.mass - s.mass) + 2 * s.mass * dpNorm1) / totalMass;
                s.vx = tx * dpTan1 + nx * m1 * 0.92;
                s.vy = ty * dpTan1 + ny * m1 * 0.92;
                o.vx = tx * dpTan2 + nx * m2 * 0.92;
                o.vy = ty * dpTan2 + ny * m2 * 0.92;
            }
        }
    }
}

function updatePhysics() {
    let anyMoving = false;
    // Smoothly resize all shapes to targetSize
    for (let s of shapes) {
        if (Math.abs(s.size - s.targetSize) > 0.5) {
            s.size += (s.targetSize - s.size) * 0.2;
            s.mass = s.size * 0.007;
        } else {
            s.size = s.targetSize;
        }
    }
    for (let i = 0; i < shapes.length; i++) {
        let s = shapes[i];
        // Gravity
        s.vy += GRAVITY;
        // Move
        s.x += s.vx;
        s.y += s.vy;
        // Boundary collisions
        if (s.x < 0) { s.x = 0; s.vx = Math.abs(s.vx) * 0.7; }
        if (s.x + s.size > canvas.width) { s.x = canvas.width - s.size; s.vx = -Math.abs(s.vx) * 0.7; }
        if (s.y < 0) { s.y = 0; s.vy = Math.abs(s.vy) * 0.7; }
        if (s.y + s.size > canvas.height) { s.y = canvas.height - s.size; s.vy = -Math.abs(s.vy) * 0.7; }
        // Damping
        s.vx *= DAMPING;
        s.vy *= DAMPING;
        // Rotation
        s.rotation += s.rotationSpeed;
        // Settle detection
        if (Math.abs(s.vx) > 0.05 || Math.abs(s.vy) > 0.05) {
            s.settled = false;
            anyMoving = true;
        } else {
            s.settled = true;
        }
    }
    resolveCollisions();
    updateConfetti();
    return anyMoving || confettiParticles.length > 0;
}

function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    let moving = updatePhysics();
    for (let s of shapes) drawShape(s);
    drawConfetti();
    if (moving) animationId = requestAnimationFrame(animate);
    else animationId = null;
}

function startAnimation() {
    if (!animationId) animationId = requestAnimationFrame(animate);
}

function clearCanvas() {
    shapes = [];
    confettiParticles = [];
    clickCount = 0;
    clickCounter.textContent = 'Clicks: 0';
    ctx.clearRect(0, 0, canvas.width, canvas.height);
}

function saveImage() {
    ctx.save();
    ctx.globalAlpha = 1.0;
    ctx.fillStyle = "#fff";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    shapes.forEach(drawShape);
    ctx.restore();

    const link = document.createElement('a');
    link.download = 'bauhaus-gravity.png';
    link.href = canvas.toDataURL();
    link.click();
}

// Detect click on shape, pop if hit, otherwise add new shape
canvas.addEventListener('click', function (e) {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    // Check if click is inside any shape (reverse for topmost)
    let popped = false;
    for (let i = shapes.length - 1; i >= 0; i--) {
        const s = shapes[i];
        const cx = s.x + s.size/2;
        const cy = s.y + s.size/2;
        const r = s.size/2;
        if (Math.hypot(mx - cx, my - cy) < r) {
            // Pop sound
            if (soundEnabled) {
                popSound.currentTime = 0;
                popSound.play();
            }
            // Confetti explosion at shape center
            spawnConfetti(cx, cy, s.color);
            shapes.splice(i, 1); // Pop the shape!
            rescaleShapes(); // Resize remaining shapes to fit screen
            // Shuffle: give all shapes a burst of random velocity
            shapes.forEach(shape => {
                shape.vx += (Math.random() - 0.5) * 10;
                shape.vy += (Math.random() - 0.5) * 10;
            });
            clickCount--;
            clickCounter.textContent = `Clicks: ${clickCount}`;
            startAnimation();
            popped = true;
            break;
        }
    }
    if (!popped) {
        handleShapeAdd(mx, my);
    }
});

canvas.addEventListener('touchstart', function (e) {
    if (e.touches.length === 1) {
        const rect = canvas.getBoundingClientRect();
        const mx = e.touches[0].clientX - rect.left;
        const my = e.touches[0].clientY - rect.top;
        // Same logic as click
        let popped = false;
        for (let i = shapes.length - 1; i >= 0; i--) {
            const s = shapes[i];
            const cx = s.x + s.size/2;
            const cy = s.y + s.size/2;
            const r = s.size/2;
            if (Math.hypot(mx - cx, my - cy) < r) {
                if (soundEnabled) {
                    popSound.currentTime = 0;
                    popSound.play();
                }
                spawnConfetti(cx, cy, s.color);
                shapes.splice(i, 1);
                rescaleShapes();
                shapes.forEach(shape => {
                    shape.vx += (Math.random() - 0.5) * 10;
                    shape.vy += (Math.random() - 0.5) * 10;
                });
                clickCount--;
                clickCounter.textContent = `Clicks: ${clickCount}`;
                startAnimation();
                popped = true;
                break;
            }
        }
        if (!popped) {
            handleShapeAdd(mx, my);
        }
    }
});

function handleShapeAdd(mouseX, mouseY) {
    clickCount++;
    clickCounter.textContent = `Clicks: ${clickCount}`;
    const shapeType = getShapeType(clickCount);
    const color = colorCycling ? COLORS[(shapes.length) % COLORS.length] : "#000";
    const shape = createShape(mouseX, mouseY, shapeType, color);

    // On spawn, ensure no overlap:
    for (let tries = 0; tries < 100; tries++) {
        let overlap = false;
        for (let s of shapes) {
            let dx = (shape.x + shape.size/2) - (s.x + s.size/2);
            let dy = (shape.y + shape.size/2) - (s.y + s.size/2);
            let dist = Math.sqrt(dx * dx + dy * dy);
            let minDist = (shape.size + s.size) / 2 * 1.08;
            if (dist < minDist) {
                let angle = Math.atan2(dy, dx);
                shape.x += Math.cos(angle) * (minDist - dist);
                shape.y += Math.sin(angle) * (minDist - dist);
                overlap = true;
            }
        }
        if (!overlap) break;
    }
    shapes.push(shape);
    rescaleShapes();
    startAnimation();
}

// Initial paint
ctx.clearRect(0, 0, canvas.width, canvas.height);
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bauhaus Gravity Generator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            background: #ffffff;
            color: #000000;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: #000000;
            color: #ffffff;
            padding: 20px;
            text-align: center;
            font-weight: 300;
            letter-spacing: 2px;
            font-size: 18px;
            text-transform: uppercase;
        }

        .controls {
            background: #f5f5f5;
            padding: 15px 20px;
            border-bottom: 1px solid #000000;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .click-counter {
            font-size: 14px;
            font-weight: bold;
            padding: 8px 12px;
            border: 1px solid #000000;
            background: #ffffff;
            min-width: 120px;
            text-align: center;
        }

        .btn {
            background: #000000;
            color: #ffffff;
            border: none;
            padding: 8px 16px;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn:hover {
            background: #333333;
        }

        .legend {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .slider-group {
            display: flex;
            align-items: center;
            gap: 10px;
            background: #ffffff;
            padding: 8px 12px;
            border: 1px solid #000000;
        }

        .slider-group label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            min-width: 60px;
        }

        .slider {
            width: 100px;
            height: 4px;
            background: #ddd;
            outline: none;
            border: none;
            appearance: none;
        }

        .slider::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            background: #000000;
            cursor: pointer;
            border-radius: 0;
        }

        .slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #000000;
            cursor: pointer;
            border-radius: 0;
            border: none;
        }

        .slider-value {
            font-size: 11px;
            min-width: 30px;
            text-align: center;
        }

        #canvas {
            flex: 1;
            display: block;
            cursor: crosshair;
            background: #ffffff;
            border: none;
        }

        .footer {
            background: #000000;
            color: #ffffff;
            padding: 10px 20px;
            text-align: center;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .shape-preview {
            width: 20px;
            height: 20px;
            border: 1px solid #000000;
            display: inline-block;
            margin-left: 5px;
        }

        .shape-preview.square {
            background: #000000;
        }

        .shape-preview.triangle {
            background: linear-gradient(45deg, #000000 50%, transparent 50%);
        }

        .shape-preview.circle {
            border-radius: 50%;
            background: #000000;
        }
    </style>
</head>
<body>
    <div class="header">
        Bauhaus Gravity Generator
    </div>
    
    <div class="controls">
        <div class="control-group">
            <div class="click-counter" id="clickCounter">Clicks: 0</div>
            <div class="legend">
                1 Click: Square <div class="shape-preview square"></div>
                2 Clicks: Triangle <div class="shape-preview triangle"></div>
                3 Clicks: Circle <div class="shape-preview circle"></div>
            </div>
        </div>
        
        <div class="control-group">
            <div class="slider-group">
                <label for="gravitySlider">Gravity:</label>
                <input type="range" id="gravitySlider" class="slider" min="0" max="1" step="0.1" value="0.3">
                <span class="slider-value" id="gravityValue">0.3</span>
            </div>
            
            <div class="slider-group">
                <label for="dampingSlider">Damping:</label>
                <input type="range" id="dampingSlider" class="slider" min="0.85" max="0.99" step="0.01" value="0.98">
                <span class="slider-value" id="dampingValue">0.98</span>
            </div>
        </div>
        
        <div class="control-group">
            <button class="btn" onclick="clearCanvas()">Clear</button>
            <button class="btn" onclick="saveImage()">Save</button>
        </div>
    </div>
    
    <canvas id="canvas"></canvas>
    
    <div class="footer">
        Physics-Based Gravity | Golden Ratio: Ï† = 1.618... | Shapes Fill 100% of Space
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const clickCounter = document.getElementById('clickCounter');
        const gravitySlider = document.getElementById('gravitySlider');
        const gravityValue = document.getElementById('gravityValue');
        const dampingSlider = document.getElementById('dampingSlider');
        const dampingValue = document.getElementById('dampingValue');
        
        let clickCount = 0;
        let shapes = [];
        let animationId = null;
        const PHI = 1.618033988749895;
        
        // Physics constants (adjustable via sliders)
        let GRAVITY = 0.3;
        let DAMPING = 0.98;
        const BOUNCE = 0.7;
        const SEPARATION_FORCE = 1.2;
        const MIN_VELOCITY = 0.05; // Threshold for settling
        const SETTLING_TIME = 60; // Frames before shape settles
        
        // Slider event listeners
        gravitySlider.addEventListener('input', function() {
            GRAVITY = parseFloat(this.value);
            gravityValue.textContent = GRAVITY.toFixed(1);
            // Wake up settled shapes if gravity changes significantly
            if (Math.abs(GRAVITY - 0.3) > 0.2) {
                shapes.forEach(shape => {
                    shape.settled = false;
                    shape.settlingTimer = 0;
                });
                startAnimation();
            }
        });
        
        dampingSlider.addEventListener('input', function() {
            DAMPING = parseFloat(this.value);
            dampingValue.textContent = DAMPING.toFixed(2);
        });
        
        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight - rect.top - 40;
            
            // Recalculate sizes for new canvas dimensions
            recalculateAllSizes();
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        function calculateOptimalSize() {
            if (shapes.length === 0) {
                // First shape gets significant portion of screen
                return Math.min(canvas.width, canvas.height) * 0.4;
            }
            
            // Calculate total available area
            const totalArea = canvas.width * canvas.height;
            const targetShapes = shapes.length + 1;
            
            // Each shape should occupy roughly equal area
            const areaPerShape = totalArea / targetShapes;
            
            // Convert area to diameter (for consistent sizing across shapes)
            let size = Math.sqrt(areaPerShape * 4 / Math.PI) * 0.9; // 90% fill factor
            
            // Apply golden ratio variation for visual interest
            const phiVariation = Math.sin(clickCount * PHI * 0.1) * 0.15 + 1;
            size *= phiVariation;
            
            // Ensure reasonable bounds
            const minSize = Math.min(canvas.width, canvas.height) * 0.05;
            const maxSize = Math.min(canvas.width, canvas.height) * 0.6;
            
            return Math.max(minSize, Math.min(size, maxSize));
        }
        
        function recalculateAllSizes() {
            if (shapes.length === 0) return;
            
            const totalArea = canvas.width * canvas.height;
            const areaPerShape = totalArea / shapes.length;
            
            shapes.forEach((shape, index) => {
                // Shape-specific area adjustments
                let areaMultiplier = 1;
                switch(shape.type) {
                    case 'square': areaMultiplier = 1.0; break;
                    case 'triangle': areaMultiplier = 1.1; break;
                    case 'circle': areaMultiplier = 0.9; break;
                }
                
                // Apply golden ratio spiral
                const phiVariation = Math.sin(index * PHI) * 0.1 + 1;
                const adjustedArea = areaPerShape * areaMultiplier * phiVariation;
                
                // Convert to size
                let newSize = Math.sqrt(adjustedArea * 4 / Math.PI) * 0.9;
                
                // Bounds checking
                const minSize = Math.min(canvas.width, canvas.height) * 0.05;
                const maxSize = Math.min(canvas.width, canvas.height) * 0.6;
                newSize = Math.max(minSize, Math.min(newSize, maxSize));
                
                shape.targetSize = newSize;
                shape.mass = newSize * 0.01; // Proportional mass
            });
        }
        
        function createShape(x, y, type) {
            const size = calculateOptimalSize();
            
            return {
                x: x - size/2,
                y: y - size/2,
                size: size,
                targetSize: size,
                type: type,
                vx: (Math.random() - 0.5) * 3,
                vy: Math.random() * -4 - 2,
                mass: size * 0.01,
                settled: false,
                settlingTimer: 0
            };
        }
        
        function updatePhysics() {
            let anyMoving = false;
            
            shapes.forEach((shape, i) => {
                // Animate size changes
                if (Math.abs(shape.size - shape.targetSize) > 0.5) {
                    shape.size += (shape.targetSize - shape.size) * 0.08;
                    shape.mass = shape.size * 0.01;
                    anyMoving = true;
                }
                
                if (!shape.settled) {
                    // Apply gravity
                    shape.vy += GRAVITY;
                    
                    // Shape separation (anti-overlap)
                    shapes.forEach((other, j) => {
                        if (i !== j) {
                            const dx = (shape.x + shape.size/2) - (other.x + other.size/2);
                            const dy = (shape.y + shape.size/2) - (other.y + other.size/2);
                            const distance = Math.sqrt(dx*dx + dy*dy);
                            const minDistance = (shape.size + other.size) / 2 + 2;
                            
                            if (distance < minDistance && distance > 0) {
                                const overlap = minDistance - distance;
                                const force = overlap * SEPARATION_FORCE;
                                const forceX = (dx / distance) * force;
                                const forceY = (dy / distance) * force;
                                
                                const massRatio = other.mass / (shape.mass + other.mass);
                                shape.vx += forceX * massRatio;
                                shape.vy += forceY * massRatio;
                            }
                        }
                    });
                    
                    // Update position
                    shape.x += shape.vx;
                    shape.y += shape.vy;
                    
                    // Boundary collisions
                    let collided = false;
                    
                    if (shape.x < 0) {
                        shape.x = 0;
                        shape.vx = Math.abs(shape.vx) * BOUNCE;
                        collided = true;
                    }
                    
                    if (shape.x + shape.size > canvas.width) {
                        shape.x = canvas.width - shape.size;
                        shape.vx = -Math.abs(shape.vx) * BOUNCE;
                        collided = true;
                    }
                    
                    if (shape.y < 0) {
                        shape.y = 0;
                        shape.vy = Math.abs(shape.vy) * BOUNCE;
                        collided = true;
                    }
                    
                    if (shape.y + shape.size >= canvas.height) {
                        shape.y = canvas.height - shape.size;
                        shape.vy = -Math.abs(shape.vy) * BOUNCE;
                        collided = true;
                    }
                    
                    // Apply damping
                    shape.vx *= DAMPING;
                    shape.vy *= DAMPING;
                    
                    // Check for settling
                    const totalVelocity = Math.sqrt(shape.vx * shape.vx + shape.vy * shape.vy);
                    
                    if (totalVelocity < MIN_VELOCITY) {
                        shape.settlingTimer++;
                        if (shape.settlingTimer > SETTLING_TIME) {
                            shape.settled = true;
                            shape.vx = 0;
                            shape.vy = 0;
                            shape.settlingTimer = 0;
                        }
                    } else {
                        shape.settlingTimer = 0;
                        anyMoving = true;
                    }
                    
                    if (totalVelocity > MIN_VELOCITY) {
                        anyMoving = true;
                    }
                }
            });
            
            return anyMoving;
        }
        
        function drawShape(shape) {
            const { x, y, size, type, settled } = shape;
            
            // Slight visual difference for settled shapes
            const alpha = settled ? 0.9 : 1.0;
            
            switch (type) {
                case 'square':
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(x, y, size, size);
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x + 1, y + 1, size - 2, size - 2);
                    break;
                    
                case 'triangle':
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.moveTo(x + size/2, y);
                    ctx.lineTo(x, y + size);
                    ctx.lineTo(x + size, y + size);
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    break;
                    
                case 'circle':
                    ctx.globalAlpha = alpha;
                    const radius = size / 2;
                    const centerX = x + radius;
                    const centerY = y + radius;
                    ctx.fillStyle = '#000000';
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    break;
            }
            ctx.globalAlpha = 1.0;
        }
        
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const isMoving = updatePhysics();
            
            shapes.forEach(drawShape);
            
            if (isMoving) {
                animationId = requestAnimationFrame(animate);
            } else {
                animationId = null;
            }
        }
        
        function startAnimation() {
            if (!animationId) {
                animationId = requestAnimationFrame(animate);
            }
        }
        
        canvas.addEventListener('click', function(e) {
            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;
            
            clickCount++;
            clickCounter.textContent = `Clicks: ${clickCount}`;
            
            // Determine shape type
            let shapeType;
            const clickMod = clickCount % 3;
            if (clickMod === 1) shapeType = 'square';
            else if (clickMod === 2) shapeType = 'triangle';
            else shapeType = 'circle';
            
            // Create new shape
            const newShape = createShape(clickX, clickY, shapeType);
            shapes.push(newShape);
            
            // Recalculate all sizes to fill 100% of space
            recalculateAllSizes();
            
            // Disturb nearby shapes
            const disturbanceRadius = 120;
            const disturbanceForce = 0.8;
            
            shapes.forEach((shape, index) => {
                if (index < shapes.length - 1) { // Don't disturb the new shape
                    const dx = (shape.x + shape.size/2) - clickX;
                    const dy = (shape.y + shape.size/2) - clickY;
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    
                    if (distance < disturbanceRadius) {
                        const force = (disturbanceRadius - distance) / disturbanceRadius * disturbanceForce;
                        const angle = Math.atan2(dy, dx);
                        
                        shape.vx += Math.cos(angle) * force * 5;
                        shape.vy += Math.sin(angle) * force * 5;
                        shape.settled = false;
                        shape.settlingTimer = 0;
                    }
                }
            });
            
            startAnimation();
        });
        
        function clearCanvas() {
            shapes = [];
            clickCount = 0;
            clickCounter.textContent = 'Clicks: 0';
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
        }
        
        function saveImage() {
            const link = document.createElement('a');
            link.download = 'bauhaus-gravity-filled.png';
            link.href = canvas.toDataURL();
            link.click();
        }
        
        // Initial setup
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    </script>
</body>
</html>

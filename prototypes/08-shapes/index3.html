<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bauhaus Gravity Generator</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            background: #fff;
            color: #000;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .header {
            background: #000;
            color: #fff;
            padding: 20px;
            text-align: center;
            font-weight: 300;
            letter-spacing: 2px;
            font-size: 18px;
            text-transform: uppercase;
        }
        .controls {
            background: #f5f5f5;
            padding: 15px 20px;
            border-bottom: 1px solid #000;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .click-counter {
            font-size: 14px;
            font-weight: bold;
            padding: 8px 12px;
            border: 1px solid #000;
            background: #fff;
            min-width: 120px;
            text-align: center;
            transition: background 0.3s;
        }
        .btn {
            background: #000;
            color: #fff;
            border: none;
            padding: 8px 16px;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .btn:hover { background: #333; }
        .legend {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .slider-group {
            display: flex;
            align-items: center;
            gap: 10px;
            background: #fff;
            padding: 8px 12px;
            border: 1px solid #000;
        }
        .slider-group label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            min-width: 60px;
        }
        .slider { width: 100px; height: 4px; background: #ddd; border: none; }
        .slider::-webkit-slider-thumb {
            appearance: none;
            width: 16px; height: 16px;
            background: #000;
            cursor: pointer;
            border-radius: 0;
        }
        .slider::-moz-range-thumb {
            width: 16px; height: 16px;
            background: #000;
            cursor: pointer;
            border-radius: 0;
            border: none;
        }
        .slider-value {
            font-size: 11px;
            min-width: 30px;
            text-align: center;
        }
        .toggle-switch {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            user-select: none;
        }
        .toggle-switch input[type="checkbox"] {
            width: 36px;
            height: 18px;
            appearance: none;
            background: #ccc;
            outline: none;
            border-radius: 9px;
            position: relative;
            transition: background 0.2s;
            cursor: pointer;
        }
        .toggle-switch input[type="checkbox"]:checked {
            background: #0197F6;
        }
        .toggle-switch input[type="checkbox"]::before {
            content: "";
            position: absolute;
            left: 2px;
            top: 2px;
            width: 14px;
            height: 14px;
            background: #fff;
            border-radius: 50%;
            transition: transform 0.2s;
        }
        .toggle-switch input[type="checkbox"]:checked::before {
            transform: translateX(18px);
        }
        #canvas {
            flex: 1;
            display: block;
            cursor: crosshair;
            background: #fff;
            border: none;
        }
        .footer {
            background: #000;
            color: #fff;
            padding: 10px 20px;
            text-align: center;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .shape-preview {
            width: 20px; height: 20px;
            border: 1px solid #000;
            display: inline-block;
            margin-left: 5px;
        }
        .shape-preview.square { background: #000; }
        .shape-preview.triangle {
            background: linear-gradient(45deg, #000 50%, transparent 50%);
        }
        .shape-preview.circle {
            border-radius: 50%;
            background: #000;
        }
    </style>
</head>
<body>
    <div class="header">Bauhaus Gravity Generator</div>
    <div class="controls">
        <div class="control-group">
            <div class="click-counter" id="clickCounter">Clicks: 0</div>
            <div class="legend">
                1 Click: Square <div class="shape-preview square"></div>
                2 Clicks: Triangle <div class="shape-preview triangle"></div>
                3 Clicks: Circle <div class="shape-preview circle"></div>
            </div>
        </div>
        <div class="control-group">
            <div class="slider-group">
                <label for="gravitySlider">Gravity:</label>
                <input type="range" id="gravitySlider" class="slider" min="0" max="1" step="0.05" value="0.3">
                <span class="slider-value" id="gravityValue">0.3</span>
            </div>
            <div class="slider-group">
                <label for="dampingSlider">Damping:</label>
                <input type="range" id="dampingSlider" class="slider" min="0.85" max="0.99" step="0.01" value="0.95">
                <span class="slider-value" id="dampingValue">0.95</span>
            </div>
            <div class="toggle-switch">
                <label for="colorToggle">Color Cycle</label>
                <input type="checkbox" id="colorToggle"/>
            </div>
        </div>
        <div class="control-group">
            <button class="btn" onclick="clearCanvas()">Clear</button>
            <button class="btn" onclick="saveImage()">Save</button>
        </div>
    </div>
    <canvas id="canvas"></canvas>
    <div class="footer">
        Physics-Based Gravity | Golden Ratio: Ï† = 1.618... | Dynamic Bauhaus Shapes
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const clickCounter = document.getElementById('clickCounter');
        const gravitySlider = document.getElementById('gravitySlider');
        const gravityValue = document.getElementById('gravityValue');
        const dampingSlider = document.getElementById('dampingSlider');
        const dampingValue = document.getElementById('dampingValue');
        const colorToggle = document.getElementById('colorToggle');

        let clickCount = 0;
        let shapes = [];
        let animationId = null;
        const PHI = 1.618033988749895;
        const COLORS = ["#D7263D", "#02182B", "#0197F6", "#FBB13C", "#56A902", "#8F3985", "#B4DFE5", "#FDE74C"];
        let colorCycling = false;

        // Physics constants
        let GRAVITY = 0.3;
        let DAMPING = 0.95;
        const BOUNCE = 0.6;
        const SEPARATION_FORCE = 0.5;
        const MIN_VELOCITY = 0.03;
        const VELOCITY_AVG_FRAMES = 12;
        const GAP_PERCENT = 0.03; // 3% gap

        // UI updates
        gravitySlider.addEventListener('input', function () {
            GRAVITY = parseFloat(this.value);
            gravityValue.textContent = GRAVITY.toFixed(2);
            shapes.forEach(shape => { shape.settled = false; });
            startAnimation();
        });
        dampingSlider.addEventListener('input', function () {
            DAMPING = parseFloat(this.value);
            dampingValue.textContent = DAMPING.toFixed(2);
        });
        colorToggle.addEventListener('change', function () {
            colorCycling = this.checked;
            // Update all shapes to reflect current color mode
            shapes.forEach((shape, i) => {
                shape.color = colorCycling ? COLORS[i % COLORS.length] : "#000";
            });
            startAnimation();
        });

        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight - rect.top - 40;
            recalculateAllSizes();
            shapes.forEach(shape => {
                shape.settled = false;
                // Keep shapes within new bounds
                shape.x = Math.max(0, Math.min(shape.x, canvas.width - shape.size));
                shape.y = Math.max(0, Math.min(shape.y, canvas.height - shape.size));
            });
            if (shapes.length > 0) startAnimation();
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function getShapeType(clickNum) {
            const clickMod = clickNum % 3;
            return clickMod === 1 ? 'square' : clickMod === 2 ? 'triangle' : 'circle';
        }

        // Calculate size so that all shapes (with gaps) tile the canvas perfectly
        function getShapeLayout(n) {
            // Try to find best grid (rows x cols) for n shapes as square as possible
            let bestCols = 1, bestRows = n, minDelta = n;
            for (let cols = 1; cols <= n; cols++) {
                let rows = Math.ceil(n / cols);
                let delta = Math.abs(canvas.width / cols - canvas.height / rows);
                if (delta < minDelta) {
                    minDelta = delta;
                    bestCols = cols;
                    bestRows = rows;
                }
            }
            return {cols: bestCols, rows: bestRows};
        }

        function recalculateAllSizes() {
            if (shapes.length === 0) return;
            const n = shapes.length;
            const {cols, rows} = getShapeLayout(n);
            const gapX = canvas.width * GAP_PERCENT / cols;
            const gapY = canvas.height * GAP_PERCENT / rows;
            const cellW = canvas.width / cols;
            const cellH = canvas.height / rows;
            const shapeW = cellW - gapX;
            const shapeH = cellH - gapY;
            // Place each shape in its cell, no overlap, with padding
            shapes.forEach((shape, idx) => {
                const col = idx % cols;
                const row = Math.floor(idx / cols);
                // Size is min of available cell width/height
                const size = Math.min(shapeW, shapeH);
                shape.targetSize = size;
                shape.mass = size * 0.007;
                shape.x = col * cellW + gapX / 2 + (cellW - size) / 2;
                shape.y = row * cellH + gapY / 2 + (cellH - size) / 2;
                shape.settled = true; // Snap directly
                shape.vx = 0; shape.vy = 0;
                shape.velocityHistory = [];
                // Color update (on color mode change)
                shape.color = colorCycling ? COLORS[idx % COLORS.length] : "#000";
            });
        }

        function createShape(x, y, type) {
            // We'll ignore the click location for tiling, but keep for animation
            const idx = shapes.length;
            const color = colorCycling ? COLORS[idx % COLORS.length] : "#000";
            return {
                x: x, // will be reassigned on recalc
                y: y,
                size: 10, // will be reassigned on recalc
                targetSize: 10,
                type: type,
                vx: 0,
                vy: 0,
                mass: 1,
                settled: true,
                rotation: Math.random() * Math.PI * 2,
                rotationSpeed: (type !== 'circle') ? (Math.random() - 0.5) * 0.04 : 0,
                color: color,
                velocityHistory: [],
            };
        }

        // No physics needed since shapes are snapped to layout, but keep animation for rotation
        function updatePhysics() {
            let anyMoving = false;
            shapes.forEach((shape) => {
                // Animate size if needed
                if (Math.abs(shape.size - shape.targetSize) > 0.5) {
                    shape.size += (shape.targetSize - shape.size) * 0.2;
                    shape.mass = shape.size * 0.007;
                    anyMoving = true;
                } else {
                    shape.size = shape.targetSize;
                }
                // Animate position if needed (should be rare)
                if (Math.abs(shape.x - shape.targetX) > 0.5 || Math.abs(shape.y - shape.targetY) > 0.5) {
                    shape.x += (shape.targetX - shape.x) * 0.2;
                    shape.y += (shape.targetY - shape.y) * 0.2;
                    anyMoving = true;
                }
                // Rotation animation
                shape.rotation += shape.rotationSpeed;
            });
            return anyMoving;
        }

        function drawShape(shape) {
            const { x, y, size, type, rotation, color } = shape;
            ctx.save();
            ctx.translate(x + size / 2, y + size / 2);
            ctx.rotate(rotation);
            ctx.globalAlpha = 0.98;
            ctx.fillStyle = color;
            ctx.strokeStyle = "#fff";
            ctx.lineWidth = 2;
            switch (type) {
                case 'square':
                    ctx.fillRect(-size / 2, -size / 2, size, size);
                    ctx.strokeRect(-size / 2 + 1, -size / 2 + 1, size - 2, size - 2);
                    break;
                case 'triangle':
                    ctx.beginPath();
                    ctx.moveTo(0, -size / 2);
                    ctx.lineTo(-size / 2, size / 2);
                    ctx.lineTo(size / 2, size / 2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    break;
                case 'circle':
                    ctx.beginPath();
                    ctx.arc(0, 0, size / 2, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                    break;
            }
            ctx.restore();
        }

        function clearCanvas() {
            shapes = [];
            clickCount = 0;
            clickCounter.textContent = 'Clicks: 0';
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
        }

        function saveImage() {
            ctx.save();
            ctx.globalAlpha = 1.0;
            ctx.fillStyle = "#fff";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            shapes.forEach(drawShape);
            ctx.restore();

            const link = document.createElement('a');
            link.download = 'bauhaus-gravity.png';
            link.href = canvas.toDataURL();
            link.click();
        }

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const isMoving = updatePhysics();
            shapes.forEach(drawShape);
            if (isMoving) animationId = requestAnimationFrame(animate);
            else animationId = null;
        }

        function startAnimation() {
            if (!animationId) animationId = requestAnimationFrame(animate);
        }

        function handleShapeAdd() {
            clickCount++;
            clickCounter.textContent = `Clicks: ${clickCount}`;
            const shapeType = getShapeType(clickCount);
            // Place at center for animation, will be snapped on recalc
            const newShape = createShape(canvas.width/2, canvas.height/2, shapeType);
            shapes.push(newShape);
            recalculateAllSizes();
            startAnimation();
        }

        canvas.addEventListener('click', function (e) {
            handleShapeAdd();
        });

        // Touch support
        canvas.addEventListener('touchstart', function (e) {
            if (e.touches.length === 1) {
                handleShapeAdd();
            }
        });

        // Initial setup
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    </script>
</body>
</html>

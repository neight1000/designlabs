<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Bauhaus Gravity Generator</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
/* ...[keep your previous styles here]... */
body { font-family: 'Helvetica Neue', Arial, sans-serif; background: #fff; color: #000; overflow: hidden; height: 100vh; display: flex; flex-direction: column;}
.header { background: #000; color: #fff; padding: 20px; text-align: center; font-weight: 300; letter-spacing: 2px; font-size: 18px; text-transform: uppercase;}
.controls { background: #f5f5f5; padding: 15px 20px; border-bottom: 1px solid #000; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px;}
.control-group { display: flex; align-items: center; gap: 15px;}
.click-counter { font-size: 14px; font-weight: bold; padding: 8px 12px; border: 1px solid #000; background: #fff; min-width: 120px; text-align: center; transition: background 0.3s;}
.btn { background: #000; color: #fff; border: none; padding: 8px 16px; font-size: 12px; text-transform: uppercase; letter-spacing: 1px; cursor: pointer; transition: all 0.2s;}
.btn:hover { background: #333;}
.legend { font-size: 11px; text-transform: uppercase; letter-spacing: 1px;}
.slider-group { display: flex; align-items: center; gap: 10px; background: #fff; padding: 8px 12px; border: 1px solid #000;}
.slider-group label { font-size: 11px; text-transform: uppercase; letter-spacing: 1px; min-width: 60px;}
.slider { width: 100px; height: 4px; background: #ddd; border: none;}
.slider::-webkit-slider-thumb { appearance: none; width: 16px; height: 16px; background: #000; cursor: pointer; border-radius: 0;}
.slider::-moz-range-thumb { width: 16px; height: 16px; background: #000; cursor: pointer; border-radius: 0; border: none;}
.slider-value { font-size: 11px; min-width: 30px; text-align: center;}
.toggle-switch { display: flex; align-items: center; gap: 8px; font-size: 11px; text-transform: uppercase; letter-spacing: 1px; user-select: none;}
.toggle-switch input[type="checkbox"] { width: 36px; height: 18px; appearance: none; background: #ccc; outline: none; border-radius: 9px; position: relative; transition: background 0.2s; cursor: pointer;}
.toggle-switch input[type="checkbox"]:checked { background: #0197F6;}
.toggle-switch input[type="checkbox"]::before { content: ""; position: absolute; left: 2px; top: 2px; width: 14px; height: 14px; background: #fff; border-radius: 50%; transition: transform 0.2s;}
.toggle-switch input[type="checkbox"]:checked::before { transform: translateX(18px);}
#canvas { flex: 1; display: block; cursor: crosshair; background: #fff; border: none;}
.footer { background: #000; color: #fff; padding: 10px 20px; text-align: center; font-size: 10px; text-transform: uppercase; letter-spacing: 1px;}
.shape-preview { width: 20px; height: 20px; border: 1px solid #000; display: inline-block; margin-left: 5px;}
.shape-preview.square { background: #000;}
.shape-preview.triangle { background: linear-gradient(45deg, #000 50%, transparent 50%);}
.shape-preview.circle { border-radius: 50%; background: #000;}
</style>
</head>
<body>
<div class="header">Bauhaus Gravity Generator</div>
<div class="controls">
    <div class="control-group">
        <div class="click-counter" id="clickCounter">Clicks: 0</div>
        <div class="legend">
            1 Click: Square <div class="shape-preview square"></div>
            2 Clicks: Triangle <div class="shape-preview triangle"></div>
            3 Clicks: Circle <div class="shape-preview circle"></div>
        </div>
    </div>
    <div class="control-group">
        <div class="slider-group">
            <label for="gravitySlider">Gravity:</label>
            <input type="range" id="gravitySlider" class="slider" min="0" max="1" step="0.05" value="0.3">
            <span class="slider-value" id="gravityValue">0.3</span>
        </div>
        <div class="slider-group">
            <label for="dampingSlider">Damping:</label>
            <input type="range" id="dampingSlider" class="slider" min="0.85" max="0.99" step="0.01" value="0.95">
            <span class="slider-value" id="dampingValue">0.95</span>
        </div>
        <div class="toggle-switch">
            <label for="colorToggle">Color Cycle</label>
            <input type="checkbox" id="colorToggle"/>
        </div>
    </div>
    <div class="control-group">
        <button class="btn" onclick="clearCanvas()">Clear</button>
        <button class="btn" onclick="saveImage()">Save</button>
    </div>
</div>
<canvas id="canvas"></canvas>
<div class="footer">
    Physics-Based Gravity | Golden Ratio: Ï† = 1.618... | Dynamic Bauhaus Shapes
</div>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const clickCounter = document.getElementById('clickCounter');
const gravitySlider = document.getElementById('gravitySlider');
const gravityValue = document.getElementById('gravityValue');
const dampingSlider = document.getElementById('dampingSlider');
const dampingValue = document.getElementById('dampingValue');
const colorToggle = document.getElementById('colorToggle');

let clickCount = 0;
let shapes = [];
let animationId = null;
const COLORS = ["#D7263D", "#02182B", "#0197F6", "#FBB13C", "#56A902", "#8F3985", "#B4DFE5", "#FDE74C"];
let colorCycling = false;
const GAP_PERCENT = 0.03; // 3% gap relative to cell size

colorToggle.addEventListener('change', function () {
    colorCycling = this.checked;
    shapes.forEach((shape, i) => {
        shape.color = colorCycling ? COLORS[i % COLORS.length] : "#000";
    });
    drawAll();
});

function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight - canvas.getBoundingClientRect().top - 40;
    relocateShapesToGrid();
    drawAll();
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

function getShapeType(clickNum) {
    const clickMod = clickNum % 3;
    return clickMod === 1 ? "square" : clickMod === 2 ? "triangle" : "circle";
}

function getGrid(n) {
    let cols = Math.ceil(Math.sqrt(n));
    let rows = Math.ceil(n / cols);
    // Try to get as close to square as possible
    while ((cols-1) * rows >= n) cols--;
    return {cols, rows};
}

function relocateShapesToGrid(animate=false, animFrom={x:0, y:0}) {
    const n = shapes.length;
    if (n === 0) return;
    const {cols, rows} = getGrid(n);
    const cellW = canvas.width / cols;
    const cellH = canvas.height / rows;
    const gapX = cellW * GAP_PERCENT;
    const gapY = cellH * GAP_PERCENT;
    const size = Math.min(cellW, cellH) - Math.max(gapX, gapY);

    shapes.forEach((shape, i) => {
        const col = i % cols;
        const row = Math.floor(i / cols);
        const x = col * cellW + (cellW - size) / 2;
        const y = row * cellH + (cellH - size) / 2;
        shape.targetX = x;
        shape.targetY = y;
        shape.size = size;
        shape.type = shape.type; // already set
        shape.color = colorCycling ? COLORS[i % COLORS.length] : "#000";
        if (animate && i === n - 1) {
            // Animate only the new shape
            shape.x = animFrom.x - size/2;
            shape.y = animFrom.y - size/2;
            shape.animating = true;
        } else {
            shape.x = x;
            shape.y = y;
            shape.animating = false;
        }
    });
}

function animateNewShape() {
    let animating = false;
    shapes.forEach(shape => {
        if (shape.animating) {
            const dx = shape.targetX - shape.x;
            const dy = shape.targetY - shape.y;
            if (Math.abs(dx) > 1 || Math.abs(dy) > 1) {
                shape.x += dx * 0.2;
                shape.y += dy * 0.2;
                animating = true;
            } else {
                shape.x = shape.targetX;
                shape.y = shape.targetY;
                shape.animating = false;
            }
        }
    });
    drawAll();
    if (animating) requestAnimationFrame(animateNewShape);
}

function drawShape(shape) {
    const {x, y, size, type, color} = shape;
    ctx.save();
    ctx.translate(x + size / 2, y + size / 2);
    ctx.rotate(shape.rotation || 0);
    ctx.globalAlpha = 0.98;
    ctx.fillStyle = color;
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 2;
    switch (type) {
        case 'square':
            ctx.fillRect(-size / 2, -size / 2, size, size);
            ctx.strokeRect(-size / 2 + 1, -size / 2 + 1, size - 2, size - 2);
            break;
        case 'triangle':
            ctx.beginPath();
            ctx.moveTo(0, -size / 2);
            ctx.lineTo(-size / 2, size / 2);
            ctx.lineTo(size / 2, size / 2);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            break;
        case 'circle':
            ctx.beginPath();
            ctx.arc(0, 0, size / 2, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
            break;
    }
    ctx.restore();
}

function drawAll() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    shapes.forEach(drawShape);
}

function clearCanvas() {
    shapes = [];
    clickCount = 0;
    clickCounter.textContent = 'Clicks: 0';
    ctx.clearRect(0, 0, canvas.width, canvas.height);
}

function saveImage() {
    ctx.save();
    ctx.globalAlpha = 1.0;
    ctx.fillStyle = "#fff";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    shapes.forEach(drawShape);
    ctx.restore();

    const link = document.createElement('a');
    link.download = 'bauhaus-gravity.png';
    link.href = canvas.toDataURL();
    link.click();
}

function handleShapeAdd(mouseX, mouseY) {
    clickCount++;
    clickCounter.textContent = `Clicks: ${clickCount}`;
    const shapeType = getShapeType(clickCount);
    const shape = {
        x: mouseX, y: mouseY, size: 10, type: shapeType,
        rotation: (shapeType !== "circle") ? (Math.random() - 0.5) * 0.2 : 0,
        color: colorCycling ? COLORS[(shapes.length) % COLORS.length] : "#000",
        animating: false
    };
    shapes.push(shape);
    relocateShapesToGrid(true, {x: mouseX, y: mouseY});
    animateNewShape();
}

canvas.addEventListener('click', function (e) {
    const rect = canvas.getBoundingClientRect();
    handleShapeAdd(e.clientX - rect.left, e.clientY - rect.top);
});

canvas.addEventListener('touchstart', function (e) {
    if (e.touches.length === 1) {
        const rect = canvas.getBoundingClientRect();
        handleShapeAdd(e.touches[0].clientX - rect.left, e.touches[0].clientY - rect.top);
    }
});

</script>
</body>
</html>

Absolutely! Here’s how you can achieve **physics-based motion** (gravity/damping, no grid) **while still scaling new shapes to fit the current screen and shape count**:

---

## **Approach**

- **Size Calculation:**  
  Each time a new shape is added, calculate the optimal size so that all shapes could theoretically fit on the canvas at once (without overlap), based on the current shape count and canvas dimensions.  
- **Physics-Based:**  
  Shapes are still physics-driven (gravity, damping, bounces, interaction), but they get this calculated size on creation—and all shapes should smoothly resize when the count changes.
- **No Grid:**  
  Placement is based on the user click, and shapes move/fall as physics dictates.

---

## **Full Example Code**

This code ensures:
- New shapes always spawn at the cursor.
- Shapes always resize together to maximize fit for the count and screen.
- Gravity and damping work.
- Color cycling toggle works.
- No grid; physics-based, but with dynamic, screen-fitting scaling.

```html
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Bauhaus Gravity Generator (Physics + Scaling)</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
body { font-family: 'Helvetica Neue', Arial, sans-serif; background: #fff; color: #000; overflow: hidden; height: 100vh; display: flex; flex-direction: column;}
.header { background: #000; color: #fff; padding: 20px; text-align: center; font-weight: 300; letter-spacing: 2px; font-size: 18px; text-transform: uppercase;}
.controls { background: #f5f5f5; padding: 15px 20px; border-bottom: 1px solid #000; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px;}
.control-group { display: flex; align-items: center; gap: 15px;}
.click-counter { font-size: 14px; font-weight: bold; padding: 8px 12px; border: 1px solid #000; background: #fff; min-width: 120px; text-align: center; transition: background 0.3s;}
.btn { background: #000; color: #fff; border: none; padding: 8px 16px; font-size: 12px; text-transform: uppercase; letter-spacing: 1px; cursor: pointer; transition: all 0.2s;}
.btn:hover { background: #333;}
.legend { font-size: 11px; text-transform: uppercase; letter-spacing: 1px;}
.slider-group { display: flex; align-items: center; gap: 10px; background: #fff; padding: 8px 12px; border: 1px solid #000;}
.slider-group label { font-size: 11px; text-transform: uppercase; letter-spacing: 1px; min-width: 60px;}
.slider { width: 100px; height: 4px; background: #ddd; border: none;}
.slider::-webkit-slider-thumb { appearance: none; width: 16px; height: 16px; background: #000; cursor: pointer; border-radius: 0;}
.slider::-moz-range-thumb { width: 16px; height: 16px; background: #000; cursor: pointer; border-radius: 0; border: none;}
.slider-value { font-size: 11px; min-width: 30px; text-align: center;}
.toggle-switch { display: flex; align-items: center; gap: 8px; font-size: 11px; text-transform: uppercase; letter-spacing: 1px; user-select: none;}
.toggle-switch input[type="checkbox"] { width: 36px; height: 18px; appearance: none; background: #ccc; outline: none; border-radius: 9px; position: relative; transition: background 0.2s; cursor: pointer;}
.toggle-switch input[type="checkbox"]:checked { background: #0197F6;}
.toggle-switch input[type="checkbox"]::before { content: ""; position: absolute; left: 2px; top: 2px; width: 14px; height: 14px; background: #fff; border-radius: 50%; transition: transform 0.2s;}
.toggle-switch input[type="checkbox"]:checked::before { transform: translateX(18px);}
#canvas { flex: 1; display: block; cursor: crosshair; background: #fff; border: none;}
.footer { background: #000; color: #fff; padding: 10px 20px; text-align: center; font-size: 10px; text-transform: uppercase; letter-spacing: 1px;}
.shape-preview { width: 20px; height: 20px; border: 1px solid #000; display: inline-block; margin-left: 5px;}
.shape-preview.square { background: #000;}
.shape-preview.triangle { background: linear-gradient(45deg, #000 50%, transparent 50%);}
.shape-preview.circle { border-radius: 50%; background: #000;}
</style>
</head>
<body>
<div class="header">Bauhaus Gravity Generator</div>
<div class="controls">
    <div class="control-group">
        <div class="click-counter" id="clickCounter">Clicks: 0</div>
        <div class="legend">
            1 Click: Square <div class="shape-preview square"></div>
            2 Clicks: Triangle <div class="shape-preview triangle"></div>
            3 Clicks: Circle <div class="shape-preview circle"></div>
        </div>
    </div>
    <div class="control-group">
        <div class="slider-group">
            <label for="gravitySlider">Gravity:</label>
            <input type="range" id="gravitySlider" class="slider" min="0" max="1" step="0.01" value="0.3">
            <span class="slider-value" id="gravityValue">0.30</span>
        </div>
        <div class="slider-group">
            <label for="dampingSlider">Damping:</label>
            <input type="range" id="dampingSlider" class="slider" min="0.85" max="0.99" step="0.01" value="0.95">
            <span class="slider-value" id="dampingValue">0.95</span>
        </div>
        <div class="toggle-switch">
            <label for="colorToggle">Color Cycle</label>
            <input type="checkbox" id="colorToggle"/>
        </div>
    </div>
    <div class="control-group">
        <button class="btn" onclick="clearCanvas()">Clear</button>
        <button class="btn" onclick="saveImage()">Save</button>
    </div>
</div>
<canvas id="canvas"></canvas>
<div class="footer">
    Physics-Based Gravity | Golden Ratio: φ = 1.618... | Dynamic Bauhaus Shapes
</div>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const clickCounter = document.getElementById('clickCounter');
const gravitySlider = document.getElementById('gravitySlider');
const gravityValue = document.getElementById('gravityValue');
const dampingSlider = document.getElementById('dampingSlider');
const dampingValue = document.getElementById('dampingValue');
const colorToggle = document.getElementById('colorToggle');

let clickCount = 0;
let shapes = [];
let animationId = null;
const COLORS = ["#D7263D", "#02182B", "#0197F6", "#FBB13C", "#56A902", "#8F3985", "#B4DFE5", "#FDE74C"];
let colorCycling = false;
let GRAVITY = parseFloat(gravitySlider.value);
let DAMPING = parseFloat(dampingSlider.value);

gravitySlider.addEventListener('input', function () {
    GRAVITY = parseFloat(this.value);
    gravityValue.textContent = GRAVITY.toFixed(2);
});
dampingSlider.addEventListener('input', function () {
    DAMPING = parseFloat(this.value);
    dampingValue.textContent = DAMPING.toFixed(2);
});
colorToggle.addEventListener('change', function () {
    colorCycling = this.checked;
    shapes.forEach((shape, i) => {
        shape.color = colorCycling ? COLORS[i % COLORS.length] : "#000";
    });
});

function getShapeType(clickNum) {
    const clickMod = clickNum % 3;
    return clickMod === 1 ? "square" : clickMod === 2 ? "triangle" : "circle";
}

function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight - canvas.getBoundingClientRect().top - 40;
    rescaleShapes();
}
window.addEventListener('resize', function() {
    resizeCanvas();
});
resizeCanvas();

function calculateOptimalShapeSize() {
    // Try to fit n shapes on the screen with a 5% margin between shapes
    if (shapes.length === 0) return 80;
    const W = canvas.width, H = canvas.height;
    const n = shapes.length;
    let cols = Math.ceil(Math.sqrt(n * W / H));
    let rows = Math.ceil(n / cols);
    let sizeX = W / cols;
    let sizeY = H / rows;
    let size = Math.min(sizeX, sizeY) * 0.90; // 10% margin for bouncing/physics
    return Math.max(30, size);
}

function rescaleShapes() {
    // When shape count or screen changes, make all shapes target new size
    let newSize = calculateOptimalShapeSize();
    for (let s of shapes) {
        s.targetSize = newSize;
    }
}

function createShape(x, y, type, color) {
    let size = calculateOptimalShapeSize();
    return {
        x: x - size / 2,
        y: y - size / 2,
        vx: (Math.random() - 0.5) * 2,
        vy: Math.random() * -2,
        size: size,
        targetSize: size,
        type: type,
        color: color,
        rotation: (type !== "circle") ? (Math.random() - 0.5) * 0.2 : 0,
        rotationSpeed: (type !== "circle") ? (Math.random() - 0.5) * 0.03 : 0,
        mass: size * 0.007,
        settled: false
    };
}

function drawShape(shape) {
    ctx.save();
    ctx.translate(shape.x + shape.size/2, shape.y + shape.size/2);
    ctx.rotate(shape.rotation || 0);
    ctx.globalAlpha = shape.settled ? 0.95 : 1.0;
    ctx.fillStyle = shape.color;
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 2;
    switch (shape.type) {
        case "square":
            ctx.fillRect(-shape.size/2, -shape.size/2, shape.size, shape.size);
            ctx.strokeRect(-shape.size/2 + 1, -shape.size/2 + 1, shape.size - 2, shape.size - 2);
            break;
        case "triangle":
            ctx.beginPath();
            ctx.moveTo(0, -shape.size/2);
            ctx.lineTo(-shape.size/2, shape.size/2);
            ctx.lineTo(shape.size/2, shape.size/2);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            break;
        case "circle":
            ctx.beginPath();
            ctx.arc(0, 0, shape.size/2, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
            break;
    }
    ctx.restore();
}

function updatePhysics() {
    let anyMoving = false;
    // Smoothly resize all shapes to targetSize
    for (let s of shapes) {
        if (Math.abs(s.size - s.targetSize) > 0.5) {
            s.size += (s.targetSize - s.size) * 0.2;
            // Adjust mass as size changes
            s.mass = s.size * 0.007;
        } else {
            s.size = s.targetSize;
        }
    }
    for (let i = 0; i < shapes.length; i++) {
        let s = shapes[i];
        // Gravity
        s.vy += GRAVITY;
        // Move
        s.x += s.vx;
        s.y += s.vy;
        // Boundary collisions
        if (s.x < 0) { s.x = 0; s.vx = Math.abs(s.vx) * 0.7; }
        if (s.x + s.size > canvas.width) { s.x = canvas.width - s.size; s.vx = -Math.abs(s.vx) * 0.7; }
        if (s.y < 0) { s.y = 0; s.vy = Math.abs(s.vy) * 0.7; }
        if (s.y + s.size > canvas.height) { s.y = canvas.height - s.size; s.vy = -Math.abs(s.vy) * 0.7; }
        // Damping
        s.vx *= DAMPING;
        s.vy *= DAMPING;
        // Rotation
        s.rotation += s.rotationSpeed;
        // Collision with other shapes (approximate as circles)
        for (let j = 0; j < shapes.length; j++) {
            if (i === j) continue;
            let o = shapes[j];
            let dx = (s.x + s.size/2) - (o.x + o.size/2);
            let dy = (s.y + s.size/2) - (o.y + o.size/2);
            let dist = Math.sqrt(dx * dx + dy * dy);
            let minDist = (s.size + o.size) / 2 * 0.92; // 8% gap for visual separation
            if (dist < minDist && dist > 0) {
                // Push apart
                let overlap = minDist - dist;
                let pushX = dx / dist * overlap * 0.5;
                let pushY = dy / dist * overlap * 0.5;
                s.x += pushX;
                s.y += pushY;
                o.x -= pushX;
                o.y -= pushY;
                // Exchange velocities (elastic)
                let tempVx = s.vx;
                let tempVy = s.vy;
                s.vx = o.vx;
                s.vy = o.vy;
                o.vx = tempVx;
                o.vy = tempVy;
            }
        }
        // Settle detection
        if (Math.abs(s.vx) > 0.05 || Math.abs(s.vy) > 0.05) {
            s.settled = false;
            anyMoving = true;
        } else {
            s.settled = true;
        }
    }
    return anyMoving;
}

function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    let moving = updatePhysics();
    for (let s of shapes) drawShape(s);
    if (moving) animationId = requestAnimationFrame(animate);
    else animationId = null;
}

function startAnimation() {
    if (!animationId) animationId = requestAnimationFrame(animate);
}

function clearCanvas() {
    shapes = [];
    clickCount = 0;
    clickCounter.textContent = 'Clicks: 0';
    ctx.clearRect(0, 0, canvas.width, canvas.height);
}

function saveImage() {
    ctx.save();
    ctx.globalAlpha = 1.0;
    ctx.fillStyle = "#fff";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    shapes.forEach(drawShape);
    ctx.restore();

    const link = document.createElement('a');
    link.download = 'bauhaus-gravity.png';
    link.href = canvas.toDataURL();
    link.click();
}

function handleShapeAdd(mouseX, mouseY) {
    clickCount++;
    clickCounter.textContent = `Clicks: ${clickCount}`;
    const shapeType = getShapeType(clickCount);
    const color = colorCycling ? COLORS[(shapes.length) % COLORS.length] : "#000";
    const shape = createShape(mouseX, mouseY, shapeType, color);
    shapes.push(shape);
    rescaleShapes();
    startAnimation();
}

canvas.addEventListener('click', function (e) {
    const rect = canvas.getBoundingClientRect();
    handleShapeAdd(e.clientX - rect.left, e.clientY - rect.top);
});
canvas.addEventListener('touchstart', function (e) {
    if (e.touches.length === 1) {
        const rect = canvas.getBoundingClientRect();
        handleShapeAdd(e.touches[0].clientX - rect.left, e.touches[0].clientY - rect.top);
    }
});

// Initial paint
ctx.clearRect(0, 0, canvas.width, canvas.height);
</script>
</body>
</html>
```

---

**How this works:**
- Every time you add a shape or resize the window, all shapes smoothly scale up or down so that the entire set fits the current screen (with a margin).
- Gravity, damping, and collision are all active.
- Shapes spawn at the mouse and behave as physics objects.
- Color cycling toggle works anytime.

Let me know if you want any further enhancements!

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Bauhaus Gravity Generator</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
body { font-family: 'Helvetica Neue', Arial, sans-serif; background: #fff; color: #000; overflow: hidden; height: 100vh; display: flex; flex-direction: column;}
.header { background: #000; color: #fff; padding: 20px; text-align: center; font-weight: 300; letter-spacing: 2px; font-size: 18px; text-transform: uppercase;}
.controls, .footer { background: #f5f5f5; padding: 15px 20px; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px;}
.click-counter { font-size: 14px; font-weight: bold; padding: 8px 12px; border: 1px solid #000; background: #fff; min-width: 120px; text-align: center;}
.btn { background: #000; color: #fff; border: none; padding: 8px 16px; font-size: 12px; text-transform: uppercase; cursor: pointer;}
.btn:hover { background: #333;}
.legend { font-size: 11px; text-transform: uppercase;}
.slider-group { display: flex; align-items: center; gap: 10px; background: #fff; padding: 8px 12px; border: 1px solid #000;}
.slider-group label { font-size: 11px; text-transform: uppercase; min-width: 60px;}
.slider { width: 100px; height: 4px;}
.toggle-switch { display: flex; align-items: center; gap: 8px; font-size: 11px; text-transform: uppercase; user-select: none;}
.toggle-switch input[type="checkbox"] { width: 36px; height: 18px; appearance: none; background: #ccc; border-radius: 9px; cursor: pointer;}
.toggle-switch input[type="checkbox"]:checked { background: #457b9d;}
.toggle-switch input[type="checkbox"]::before { content: ""; position: absolute; left: 2px; top: 2px; width: 14px; height: 14px; background: #fff; border-radius: 50%; transition: transform 0.2s;}
.toggle-switch input[type="checkbox"]:checked::before { transform: translateX(18px);}
#canvas { flex: 1; display: block; cursor: crosshair; background: #fff; border: none;}
.footer { background: #000; color: #fff; text-align: center; font-size: 10px; text-transform: uppercase; letter-spacing: 1px;}
</style>
</head>
<body>
<div class="header">Bauhaus Gravity Generator</div>
<div class="controls">
    <div style="display:flex;gap:20px;align-items:center">
        <div class="click-counter" id="clickCounter">Clicks: 0</div>
        <div class="legend">
            1 Click: Square | 2 Clicks: Triangle | 3 Clicks: Circle
        </div>
    </div>
    <div style="display:flex;gap:10px;align-items:center">
        <div class="slider-group">
            <label for="gravitySlider">Gravity:</label>
            <input type="range" id="gravitySlider" class="slider" min="0" max="1" step="0.01" value="0.3">
            <span id="gravityValue">0.30</span>
        </div>
        <div class="slider-group">
            <label for="dampingSlider">Damping:</label>
            <input type="range" id="dampingSlider" class="slider" min="0.85" max="0.99" step="0.01" value="0.95">
            <span id="dampingValue">0.95</span>
        </div>
        <div class="toggle-switch">
            <label for="colorToggle">Color Cycle</label>
            <input type="checkbox" id="colorToggle"/>
        </div>
    </div>
    <div>
        <button class="btn" onclick="clearCanvas()">Clear</button>
        <button class="btn" onclick="saveImage()">Save</button>
    </div>
</div>
<canvas id="canvas"></canvas>
<div class="footer">
    No Overlap &middot; Bauhaus Colors Only (Black, Red, Blue, Yellow)
</div>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const clickCounter = document.getElementById('clickCounter');
const gravitySlider = document.getElementById('gravitySlider');
const gravityValue = document.getElementById('gravityValue');
const dampingSlider = document.getElementById('dampingSlider');
const dampingValue = document.getElementById('dampingValue');
const colorToggle = document.getElementById('colorToggle');

let clickCount = 0;
let shapes = [];
let animationId = null;

// Bauhaus palette: black, red, blue, yellow
const BAUHAUS_COLORS = ['#000', '#e63946', '#457b9d', '#ffd60a'];
let colorCycling = false;
let GRAVITY = parseFloat(gravitySlider.value);
let DAMPING = parseFloat(dampingSlider.value);

gravitySlider.addEventListener('input', function () {
    GRAVITY = parseFloat(this.value);
    gravityValue.textContent = GRAVITY.toFixed(2);
});
dampingSlider.addEventListener('input', function () {
    DAMPING = parseFloat(this.value);
    dampingValue.textContent = DAMPING.toFixed(2);
});
colorToggle.addEventListener('change', function () {
    colorCycling = this.checked;
    shapes.forEach((shape, i) => {
        shape.color = colorCycling ? BAUHAUS_COLORS[i % BAUHAUS_COLORS.length] : "#000";
    });
});

function getShapeType(clickNum) {
    const clickMod = clickNum % 3;
    return clickMod === 1 ? "square" : clickMod === 2 ? "triangle" : "circle";
}

function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight - canvas.getBoundingClientRect().top - 40;
    rescaleShapes();
}
window.addEventListener('resize', function() {
    resizeCanvas();
});
resizeCanvas();

function calculateOptimalShapeSize() {
    if (shapes.length === 0) return 80;
    const W = canvas.width, H = canvas.height;
    const n = shapes.length;
    let cols = Math.ceil(Math.sqrt(n * W / H));
    let rows = Math.ceil(n / cols);
    let sizeX = W / cols;
    let sizeY = H / rows;
    let size = Math.min(sizeX, sizeY) * 0.88;
    return Math.max(30, size);
}

function rescaleShapes() {
    let newSize = calculateOptimalShapeSize();
    for (let s of shapes) {
        s.targetSize = newSize;
    }
}

function createShape(x, y, type, color) {
    let size = calculateOptimalShapeSize();
    return {
        x: x - size / 2,
        y: y - size / 2,
        vx: (Math.random() - 0.5) * 2,
        vy: Math.random() * -2,
        size: size,
        targetSize: size,
        type: type,
        color: color,
        rotation: (type !== "circle") ? (Math.random() - 0.5) * 0.2 : 0,
        rotationSpeed: (type !== "circle") ? (Math.random() - 0.5) * 0.03 : 0,
        mass: size * 0.007,
        settled: false
    };
}

function drawShape(shape) {
    ctx.save();
    ctx.translate(shape.x + shape.size/2, shape.y + shape.size/2);
    ctx.rotate(shape.rotation || 0);
    ctx.globalAlpha = shape.settled ? 0.95 : 1.0;
    ctx.fillStyle = shape.color;
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 2;
    switch (shape.type) {
        case "square":
            ctx.fillRect(-shape.size/2, -shape.size/2, shape.size, shape.size);
            ctx.strokeRect(-shape.size/2 + 1, -shape.size/2 + 1, shape.size - 2, shape.size - 2);
            break;
        case "triangle":
            ctx.beginPath();
            ctx.moveTo(0, -shape.size/2);
            ctx.lineTo(-shape.size/2, shape.size/2);
            ctx.lineTo(shape.size/2, shape.size/2);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            break;
        case "circle":
            ctx.beginPath();
            ctx.arc(0, 0, shape.size/2, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
            break;
    }
    ctx.restore();
}

// Collision resolution with minimum separation margin
function resolveCollisions() {
    const separationMargin = 0.08;
    for (let i = 0; i < shapes.length; i++) {
        let s = shapes[i];
        for (let j = i + 1; j < shapes.length; j++) {
            let o = shapes[j];
            let dx = (s.x + s.size/2) - (o.x + o.size/2);
            let dy = (s.y + s.size/2) - (o.y + o.size/2);
            let dist = Math.sqrt(dx * dx + dy * dy);
            let minDist = (s.size + o.size) / 2 * (1 + separationMargin);
            if (dist < minDist && dist > 0) {
                // Minimum translation vector
                let overlap = minDist - dist;
                let nx = dx / dist;
                let ny = dy / dist;
                let totalMass = s.mass + o.mass;
                let pushS = (overlap * (o.mass / totalMass));
                let pushO = (overlap * (s.mass / totalMass));
                s.x += nx * pushS;
                s.y += ny * pushS;
                o.x -= nx * pushO;
                o.y -= ny * pushO;
                // Exchange velocities (elastic, but damped)
                let tx = -ny, ty = nx;
                let dpTan1 = s.vx * tx + s.vy * ty;
                let dpTan2 = o.vx * tx + o.vy * ty;
                let dpNorm1 = s.vx * nx + s.vy * ny;
                let dpNorm2 = o.vx * nx + o.vy * ny;
                let m1 = (dpNorm1 * (s.mass - o.mass) + 2 * o.mass * dpNorm2) / totalMass;
                let m2 = (dpNorm2 * (o.mass - s.mass) + 2 * s.mass * dpNorm1) / totalMass;
                s.vx = tx * dpTan1 + nx * m1 * 0.92;
                s.vy = ty * dpTan1 + ny * m1 * 0.92;
                o.vx = tx * dpTan2 + nx * m2 * 0.92;
                o.vy = ty * dpTan2 + ny * m2 * 0.92;
            }
        }
    }
}

function updatePhysics() {
    let anyMoving = false;
    // Smoothly resize all shapes to targetSize
    for (let s of shapes) {
        if (Math.abs(s.size - s.targetSize) > 0.5) {
            s.size += (s.targetSize - s.size) * 0.2;
            s.mass = s.size * 0.007;
        } else {
            s.size = s.targetSize;
        }
    }
    for (let i = 0; i < shapes.length; i++) {
        let s = shapes[i];
        // Gravity
        s.vy += GRAVITY;
        // Move
        s.x += s.vx;
        s.y += s.vy;
        // Boundary collisions
        if (s.x < 0) { s.x = 0; s.vx = Math.abs(s.vx) * 0.7; }
        if (s.x + s.size > canvas.width) { s.x = canvas.width - s.size; s.vx = -Math.abs(s.vx) * 0.7; }
        if (s.y < 0) { s.y = 0; s.vy = Math.abs(s.vy) * 0.7; }
        if (s.y + s.size > canvas.height) { s.y = canvas.height - s.size; s.vy = -Math.abs(s.vy) * 0.7; }
        // Damping
        s.vx *= DAMPING;
        s.vy *= DAMPING;
        // Rotation
        s.rotation += s.rotationSpeed;
        // Settle detection
        if (Math.abs(s.vx) > 0.05 || Math.abs(s.vy) > 0.05) {
            s.settled = false;
            anyMoving = true;
        } else {
            s.settled = true;
        }
    }
    resolveCollisions();
    return anyMoving;
}

function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    let moving = updatePhysics();
    for (let s of shapes) drawShape(s);
    if (moving) animationId = requestAnimationFrame(animate);
    else animationId = null;
}

function startAnimation() {
    if (!animationId) animationId = requestAnimationFrame(animate);
}

function clearCanvas() {
    shapes = [];
    clickCount = 0;
    clickCounter.textContent = 'Clicks: 0';
    ctx.clearRect(0, 0, canvas.width, canvas.height);
}

function saveImage() {
    ctx.save();
    ctx.globalAlpha = 1.0;
    ctx.fillStyle = "#fff";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    shapes.forEach(drawShape);
    ctx.restore();

    const link = document.createElement('a');
    link.download = 'bauhaus-gravity.png';
    link.href = canvas.toDataURL();
    link.click();
}

canvas.addEventListener('click', function (e) {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    // Pop shape if clicked, else add
    let popped = false;
    for (let i = shapes.length - 1; i >= 0; i--) {
        const s = shapes[i];
        const cx = s.x + s.size/2;
        const cy = s.y + s.size/2;
        const r = s.size/2;
        if (Math.hypot(mx - cx, my - cy) < r) {
            shapes.splice(i, 1);
            rescaleShapes();
            shapes.forEach(shape => {
                shape.vx += (Math.random() - 0.5) * 10;
                shape.vy += (Math.random() - 0.5) * 10;
            });
            clickCount--;
            clickCounter.textContent = `Clicks: ${clickCount}`;
            startAnimation();
            popped = true;
            break;
        }
    }
    if (!popped) {
        handleShapeAdd(mx, my);
    }
});

function handleShapeAdd(mouseX, mouseY) {
    clickCount++;
    clickCounter.textContent = `Clicks: ${clickCount}`;
    const shapeType = getShapeType(clickCount);
    const color = colorCycling ? BAUHAUS_COLORS[(shapes.length) % BAUHAUS_COLORS.length] : "#000";
    const shape = createShape(mouseX, mouseY, shapeType, color);

    // On spawn, ensure no overlap:
    for (let tries = 0; tries < 100; tries++) {
        let overlap = false;
        for (let s of shapes) {
            let dx = (shape.x + shape.size/2) - (s.x + s.size/2);
            let dy = (shape.y + shape.size/2) - (s.y + s.size/2);
            let dist = Math.sqrt(dx * dx + dy * dy);
            let minDist = (shape.size + s.size) / 2 * 1.08;
            if (dist < minDist) {
                let angle = Math.atan2(dy, dx);
                shape.x += Math.cos(angle) * (minDist - dist);
                shape.y += Math.sin(angle) * (minDist - dist);
                overlap = true;
            }
        }
        if (!overlap) break;
    }
    shapes.push(shape);
    rescaleShapes();
    startAnimation();
}

ctx.clearRect(0, 0, canvas.width, canvas.height);
</script>
</body>
</html>
